# Yet another raylib wrapper for Ruby
#
# * https://github.com/vaiorabbit/raylib-bindings
#
# [NOTICE] Autogenerated. Do not edit.

require 'ffi'

module Raylib
  extend FFI::Library

  # Define/Macro

  RAYLIB_VERSION = "4.5-dev"
  DEG2RAD = Math::PI / 180.0
  RAD2DEG = 180.0 / Math::PI

  # Enum

  # enum ConfigFlags
  # System/Window config flags
  FLAG_VSYNC_HINT = 64 # Set to try enabling V-Sync on GPU
  FLAG_FULLSCREEN_MODE = 2 # Set to run program in fullscreen
  FLAG_WINDOW_RESIZABLE = 4 # Set to allow resizable window
  FLAG_WINDOW_UNDECORATED = 8 # Set to disable window decoration (frame and buttons)
  FLAG_WINDOW_HIDDEN = 128 # Set to hide window
  FLAG_WINDOW_MINIMIZED = 512 # Set to minimize window (iconify)
  FLAG_WINDOW_MAXIMIZED = 1024 # Set to maximize window (expanded to monitor)
  FLAG_WINDOW_UNFOCUSED = 2048 # Set to window non focused
  FLAG_WINDOW_TOPMOST = 4096 # Set to window always on top
  FLAG_WINDOW_ALWAYS_RUN = 256 # Set to allow windows running while minimized
  FLAG_WINDOW_TRANSPARENT = 16 # Set to allow transparent framebuffer
  FLAG_WINDOW_HIGHDPI = 8192 # Set to support HighDPI
  FLAG_WINDOW_MOUSE_PASSTHROUGH = 16384 # Set to support mouse passthrough, only supported when FLAG_WINDOW_UNDECORATED
  FLAG_MSAA_4X_HINT = 32 # Set to try enabling MSAA 4X
  FLAG_INTERLACED_HINT = 65536 # Set to try enabling interlaced video format (for V3D)

  # enum TraceLogLevel
  # Trace log level
  LOG_ALL = 0 # Display all logs
  LOG_TRACE = 1 # Trace logging, intended for internal use only
  LOG_DEBUG = 2 # Debug logging, used for internal debugging, it should be disabled on release builds
  LOG_INFO = 3 # Info logging, used for program execution info
  LOG_WARNING = 4 # Warning logging, used on recoverable failures
  LOG_ERROR = 5 # Error logging, used on unrecoverable failures
  LOG_FATAL = 6 # Fatal logging, used to abort program: exit(EXIT_FAILURE)
  LOG_NONE = 7 # Disable logging

  # enum KeyboardKey
  # Keyboard keys (US keyboard layout)
  KEY_NULL = 0 # Key: NULL, used for no key pressed
  KEY_APOSTROPHE = 39 # Key: '
  KEY_COMMA = 44 # Key: ,
  KEY_MINUS = 45 # Key: -
  KEY_PERIOD = 46 # Key: .
  KEY_SLASH = 47 # Key: /
  KEY_ZERO = 48 # Key: 0
  KEY_ONE = 49 # Key: 1
  KEY_TWO = 50 # Key: 2
  KEY_THREE = 51 # Key: 3
  KEY_FOUR = 52 # Key: 4
  KEY_FIVE = 53 # Key: 5
  KEY_SIX = 54 # Key: 6
  KEY_SEVEN = 55 # Key: 7
  KEY_EIGHT = 56 # Key: 8
  KEY_NINE = 57 # Key: 9
  KEY_SEMICOLON = 59 # Key: ;
  KEY_EQUAL = 61 # Key: =
  KEY_A = 65 # Key: A | a
  KEY_B = 66 # Key: B | b
  KEY_C = 67 # Key: C | c
  KEY_D = 68 # Key: D | d
  KEY_E = 69 # Key: E | e
  KEY_F = 70 # Key: F | f
  KEY_G = 71 # Key: G | g
  KEY_H = 72 # Key: H | h
  KEY_I = 73 # Key: I | i
  KEY_J = 74 # Key: J | j
  KEY_K = 75 # Key: K | k
  KEY_L = 76 # Key: L | l
  KEY_M = 77 # Key: M | m
  KEY_N = 78 # Key: N | n
  KEY_O = 79 # Key: O | o
  KEY_P = 80 # Key: P | p
  KEY_Q = 81 # Key: Q | q
  KEY_R = 82 # Key: R | r
  KEY_S = 83 # Key: S | s
  KEY_T = 84 # Key: T | t
  KEY_U = 85 # Key: U | u
  KEY_V = 86 # Key: V | v
  KEY_W = 87 # Key: W | w
  KEY_X = 88 # Key: X | x
  KEY_Y = 89 # Key: Y | y
  KEY_Z = 90 # Key: Z | z
  KEY_LEFT_BRACKET = 91 # Key: [
  KEY_BACKSLASH = 92 # Key: '\'
  KEY_RIGHT_BRACKET = 93 # Key: ]
  KEY_GRAVE = 96 # Key: `
  KEY_SPACE = 32 # Key: Space
  KEY_ESCAPE = 256 # Key: Esc
  KEY_ENTER = 257 # Key: Enter
  KEY_TAB = 258 # Key: Tab
  KEY_BACKSPACE = 259 # Key: Backspace
  KEY_INSERT = 260 # Key: Ins
  KEY_DELETE = 261 # Key: Del
  KEY_RIGHT = 262 # Key: Cursor right
  KEY_LEFT = 263 # Key: Cursor left
  KEY_DOWN = 264 # Key: Cursor down
  KEY_UP = 265 # Key: Cursor up
  KEY_PAGE_UP = 266 # Key: Page up
  KEY_PAGE_DOWN = 267 # Key: Page down
  KEY_HOME = 268 # Key: Home
  KEY_END = 269 # Key: End
  KEY_CAPS_LOCK = 280 # Key: Caps lock
  KEY_SCROLL_LOCK = 281 # Key: Scroll down
  KEY_NUM_LOCK = 282 # Key: Num lock
  KEY_PRINT_SCREEN = 283 # Key: Print screen
  KEY_PAUSE = 284 # Key: Pause
  KEY_F1 = 290 # Key: F1
  KEY_F2 = 291 # Key: F2
  KEY_F3 = 292 # Key: F3
  KEY_F4 = 293 # Key: F4
  KEY_F5 = 294 # Key: F5
  KEY_F6 = 295 # Key: F6
  KEY_F7 = 296 # Key: F7
  KEY_F8 = 297 # Key: F8
  KEY_F9 = 298 # Key: F9
  KEY_F10 = 299 # Key: F10
  KEY_F11 = 300 # Key: F11
  KEY_F12 = 301 # Key: F12
  KEY_LEFT_SHIFT = 340 # Key: Shift left
  KEY_LEFT_CONTROL = 341 # Key: Control left
  KEY_LEFT_ALT = 342 # Key: Alt left
  KEY_LEFT_SUPER = 343 # Key: Super left
  KEY_RIGHT_SHIFT = 344 # Key: Shift right
  KEY_RIGHT_CONTROL = 345 # Key: Control right
  KEY_RIGHT_ALT = 346 # Key: Alt right
  KEY_RIGHT_SUPER = 347 # Key: Super right
  KEY_KB_MENU = 348 # Key: KB menu
  KEY_KP_0 = 320 # Key: Keypad 0
  KEY_KP_1 = 321 # Key: Keypad 1
  KEY_KP_2 = 322 # Key: Keypad 2
  KEY_KP_3 = 323 # Key: Keypad 3
  KEY_KP_4 = 324 # Key: Keypad 4
  KEY_KP_5 = 325 # Key: Keypad 5
  KEY_KP_6 = 326 # Key: Keypad 6
  KEY_KP_7 = 327 # Key: Keypad 7
  KEY_KP_8 = 328 # Key: Keypad 8
  KEY_KP_9 = 329 # Key: Keypad 9
  KEY_KP_DECIMAL = 330 # Key: Keypad .
  KEY_KP_DIVIDE = 331 # Key: Keypad /
  KEY_KP_MULTIPLY = 332 # Key: Keypad *
  KEY_KP_SUBTRACT = 333 # Key: Keypad -
  KEY_KP_ADD = 334 # Key: Keypad +
  KEY_KP_ENTER = 335 # Key: Keypad Enter
  KEY_KP_EQUAL = 336 # Key: Keypad =
  KEY_BACK = 4 # Key: Android back button
  KEY_MENU = 82 # Key: Android menu button
  KEY_VOLUME_UP = 24 # Key: Android volume up button
  KEY_VOLUME_DOWN = 25 # Key: Android volume down button

  # enum MouseButton
  # Mouse buttons
  MOUSE_BUTTON_LEFT = 0 # Mouse button left
  MOUSE_BUTTON_RIGHT = 1 # Mouse button right
  MOUSE_BUTTON_MIDDLE = 2 # Mouse button middle (pressed wheel)
  MOUSE_BUTTON_SIDE = 3 # Mouse button side (advanced mouse device)
  MOUSE_BUTTON_EXTRA = 4 # Mouse button extra (advanced mouse device)
  MOUSE_BUTTON_FORWARD = 5 # Mouse button forward (advanced mouse device)
  MOUSE_BUTTON_BACK = 6 # Mouse button back (advanced mouse device)

  # enum MouseCursor
  # Mouse cursor
  MOUSE_CURSOR_DEFAULT = 0 # Default pointer shape
  MOUSE_CURSOR_ARROW = 1 # Arrow shape
  MOUSE_CURSOR_IBEAM = 2 # Text writing cursor shape
  MOUSE_CURSOR_CROSSHAIR = 3 # Cross shape
  MOUSE_CURSOR_POINTING_HAND = 4 # Pointing hand cursor
  MOUSE_CURSOR_RESIZE_EW = 5 # Horizontal resize/move arrow shape
  MOUSE_CURSOR_RESIZE_NS = 6 # Vertical resize/move arrow shape
  MOUSE_CURSOR_RESIZE_NWSE = 7 # Top-left to bottom-right diagonal resize/move arrow shape
  MOUSE_CURSOR_RESIZE_NESW = 8 # The top-right to bottom-left diagonal resize/move arrow shape
  MOUSE_CURSOR_RESIZE_ALL = 9 # The omni-directional resize/move cursor shape
  MOUSE_CURSOR_NOT_ALLOWED = 10 # The operation-not-allowed shape

  # enum GamepadButton
  # Gamepad buttons
  GAMEPAD_BUTTON_UNKNOWN = 0 # Unknown button, just for error checking
  GAMEPAD_BUTTON_LEFT_FACE_UP = 1 # Gamepad left DPAD up button
  GAMEPAD_BUTTON_LEFT_FACE_RIGHT = 2 # Gamepad left DPAD right button
  GAMEPAD_BUTTON_LEFT_FACE_DOWN = 3 # Gamepad left DPAD down button
  GAMEPAD_BUTTON_LEFT_FACE_LEFT = 4 # Gamepad left DPAD left button
  GAMEPAD_BUTTON_RIGHT_FACE_UP = 5 # Gamepad right button up (i.e. PS3: Triangle, Xbox: Y)
  GAMEPAD_BUTTON_RIGHT_FACE_RIGHT = 6 # Gamepad right button right (i.e. PS3: Square, Xbox: X)
  GAMEPAD_BUTTON_RIGHT_FACE_DOWN = 7 # Gamepad right button down (i.e. PS3: Cross, Xbox: A)
  GAMEPAD_BUTTON_RIGHT_FACE_LEFT = 8 # Gamepad right button left (i.e. PS3: Circle, Xbox: B)
  GAMEPAD_BUTTON_LEFT_TRIGGER_1 = 9 # Gamepad top/back trigger left (first), it could be a trailing button
  GAMEPAD_BUTTON_LEFT_TRIGGER_2 = 10 # Gamepad top/back trigger left (second), it could be a trailing button
  GAMEPAD_BUTTON_RIGHT_TRIGGER_1 = 11 # Gamepad top/back trigger right (one), it could be a trailing button
  GAMEPAD_BUTTON_RIGHT_TRIGGER_2 = 12 # Gamepad top/back trigger right (second), it could be a trailing button
  GAMEPAD_BUTTON_MIDDLE_LEFT = 13 # Gamepad center buttons, left one (i.e. PS3: Select)
  GAMEPAD_BUTTON_MIDDLE = 14 # Gamepad center buttons, middle one (i.e. PS3: PS, Xbox: XBOX)
  GAMEPAD_BUTTON_MIDDLE_RIGHT = 15 # Gamepad center buttons, right one (i.e. PS3: Start)
  GAMEPAD_BUTTON_LEFT_THUMB = 16 # Gamepad joystick pressed button left
  GAMEPAD_BUTTON_RIGHT_THUMB = 17 # Gamepad joystick pressed button right

  # enum GamepadAxis
  # Gamepad axis
  GAMEPAD_AXIS_LEFT_X = 0 # Gamepad left stick X axis
  GAMEPAD_AXIS_LEFT_Y = 1 # Gamepad left stick Y axis
  GAMEPAD_AXIS_RIGHT_X = 2 # Gamepad right stick X axis
  GAMEPAD_AXIS_RIGHT_Y = 3 # Gamepad right stick Y axis
  GAMEPAD_AXIS_LEFT_TRIGGER = 4 # Gamepad back trigger left, pressure level: [1..-1]
  GAMEPAD_AXIS_RIGHT_TRIGGER = 5 # Gamepad back trigger right, pressure level: [1..-1]

  # enum MaterialMapIndex
  # Material map index
  MATERIAL_MAP_ALBEDO = 0 # Albedo material (same as: MATERIAL_MAP_DIFFUSE)
  MATERIAL_MAP_METALNESS = 1 # Metalness material (same as: MATERIAL_MAP_SPECULAR)
  MATERIAL_MAP_NORMAL = 2 # Normal material
  MATERIAL_MAP_ROUGHNESS = 3 # Roughness material
  MATERIAL_MAP_OCCLUSION = 4 # Ambient occlusion material
  MATERIAL_MAP_EMISSION = 5 # Emission material
  MATERIAL_MAP_HEIGHT = 6 # Heightmap material
  MATERIAL_MAP_CUBEMAP = 7 # Cubemap material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
  MATERIAL_MAP_IRRADIANCE = 8 # Irradiance material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
  MATERIAL_MAP_PREFILTER = 9 # Prefilter material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
  MATERIAL_MAP_BRDF = 10 # Brdf material

  # enum ShaderLocationIndex
  # Shader location index
  SHADER_LOC_VERTEX_POSITION = 0 # Shader location: vertex attribute: position
  SHADER_LOC_VERTEX_TEXCOORD01 = 1 # Shader location: vertex attribute: texcoord01
  SHADER_LOC_VERTEX_TEXCOORD02 = 2 # Shader location: vertex attribute: texcoord02
  SHADER_LOC_VERTEX_NORMAL = 3 # Shader location: vertex attribute: normal
  SHADER_LOC_VERTEX_TANGENT = 4 # Shader location: vertex attribute: tangent
  SHADER_LOC_VERTEX_COLOR = 5 # Shader location: vertex attribute: color
  SHADER_LOC_MATRIX_MVP = 6 # Shader location: matrix uniform: model-view-projection
  SHADER_LOC_MATRIX_VIEW = 7 # Shader location: matrix uniform: view (camera transform)
  SHADER_LOC_MATRIX_PROJECTION = 8 # Shader location: matrix uniform: projection
  SHADER_LOC_MATRIX_MODEL = 9 # Shader location: matrix uniform: model (transform)
  SHADER_LOC_MATRIX_NORMAL = 10 # Shader location: matrix uniform: normal
  SHADER_LOC_VECTOR_VIEW = 11 # Shader location: vector uniform: view
  SHADER_LOC_COLOR_DIFFUSE = 12 # Shader location: vector uniform: diffuse color
  SHADER_LOC_COLOR_SPECULAR = 13 # Shader location: vector uniform: specular color
  SHADER_LOC_COLOR_AMBIENT = 14 # Shader location: vector uniform: ambient color
  SHADER_LOC_MAP_ALBEDO = 15 # Shader location: sampler2d texture: albedo (same as: SHADER_LOC_MAP_DIFFUSE)
  SHADER_LOC_MAP_METALNESS = 16 # Shader location: sampler2d texture: metalness (same as: SHADER_LOC_MAP_SPECULAR)
  SHADER_LOC_MAP_NORMAL = 17 # Shader location: sampler2d texture: normal
  SHADER_LOC_MAP_ROUGHNESS = 18 # Shader location: sampler2d texture: roughness
  SHADER_LOC_MAP_OCCLUSION = 19 # Shader location: sampler2d texture: occlusion
  SHADER_LOC_MAP_EMISSION = 20 # Shader location: sampler2d texture: emission
  SHADER_LOC_MAP_HEIGHT = 21 # Shader location: sampler2d texture: height
  SHADER_LOC_MAP_CUBEMAP = 22 # Shader location: samplerCube texture: cubemap
  SHADER_LOC_MAP_IRRADIANCE = 23 # Shader location: samplerCube texture: irradiance
  SHADER_LOC_MAP_PREFILTER = 24 # Shader location: samplerCube texture: prefilter
  SHADER_LOC_MAP_BRDF = 25 # Shader location: sampler2d texture: brdf

  # enum ShaderUniformDataType
  # Shader uniform data type
  SHADER_UNIFORM_FLOAT = 0 # Shader uniform type: float
  SHADER_UNIFORM_VEC2 = 1 # Shader uniform type: vec2 (2 float)
  SHADER_UNIFORM_VEC3 = 2 # Shader uniform type: vec3 (3 float)
  SHADER_UNIFORM_VEC4 = 3 # Shader uniform type: vec4 (4 float)
  SHADER_UNIFORM_INT = 4 # Shader uniform type: int
  SHADER_UNIFORM_IVEC2 = 5 # Shader uniform type: ivec2 (2 int)
  SHADER_UNIFORM_IVEC3 = 6 # Shader uniform type: ivec3 (3 int)
  SHADER_UNIFORM_IVEC4 = 7 # Shader uniform type: ivec4 (4 int)
  SHADER_UNIFORM_SAMPLER2D = 8 # Shader uniform type: sampler2d

  # enum ShaderAttributeDataType
  # Shader attribute data types
  SHADER_ATTRIB_FLOAT = 0 # Shader attribute type: float
  SHADER_ATTRIB_VEC2 = 1 # Shader attribute type: vec2 (2 float)
  SHADER_ATTRIB_VEC3 = 2 # Shader attribute type: vec3 (3 float)
  SHADER_ATTRIB_VEC4 = 3 # Shader attribute type: vec4 (4 float)

  # enum PixelFormat
  # Pixel formats
  PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = 1 # 8 bit per pixel (no alpha)
  PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA = 2 # 8*2 bpp (2 channels)
  PIXELFORMAT_UNCOMPRESSED_R5G6B5 = 3 # 16 bpp
  PIXELFORMAT_UNCOMPRESSED_R8G8B8 = 4 # 24 bpp
  PIXELFORMAT_UNCOMPRESSED_R5G5B5A1 = 5 # 16 bpp (1 bit alpha)
  PIXELFORMAT_UNCOMPRESSED_R4G4B4A4 = 6 # 16 bpp (4 bit alpha)
  PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 = 7 # 32 bpp
  PIXELFORMAT_UNCOMPRESSED_R32 = 8 # 32 bpp (1 channel - float)
  PIXELFORMAT_UNCOMPRESSED_R32G32B32 = 9 # 32*3 bpp (3 channels - float)
  PIXELFORMAT_UNCOMPRESSED_R32G32B32A32 = 10 # 32*4 bpp (4 channels - float)
  PIXELFORMAT_COMPRESSED_DXT1_RGB = 11 # 4 bpp (no alpha)
  PIXELFORMAT_COMPRESSED_DXT1_RGBA = 12 # 4 bpp (1 bit alpha)
  PIXELFORMAT_COMPRESSED_DXT3_RGBA = 13 # 8 bpp
  PIXELFORMAT_COMPRESSED_DXT5_RGBA = 14 # 8 bpp
  PIXELFORMAT_COMPRESSED_ETC1_RGB = 15 # 4 bpp
  PIXELFORMAT_COMPRESSED_ETC2_RGB = 16 # 4 bpp
  PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA = 17 # 8 bpp
  PIXELFORMAT_COMPRESSED_PVRT_RGB = 18 # 4 bpp
  PIXELFORMAT_COMPRESSED_PVRT_RGBA = 19 # 4 bpp
  PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA = 20 # 8 bpp
  PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA = 21 # 2 bpp

  # enum TextureFilter
  # Texture parameters: filter mode
  TEXTURE_FILTER_POINT = 0 # No filter, just pixel approximation
  TEXTURE_FILTER_BILINEAR = 1 # Linear filtering
  TEXTURE_FILTER_TRILINEAR = 2 # Trilinear filtering (linear with mipmaps)
  TEXTURE_FILTER_ANISOTROPIC_4X = 3 # Anisotropic filtering 4x
  TEXTURE_FILTER_ANISOTROPIC_8X = 4 # Anisotropic filtering 8x
  TEXTURE_FILTER_ANISOTROPIC_16X = 5 # Anisotropic filtering 16x

  # enum TextureWrap
  # Texture parameters: wrap mode
  TEXTURE_WRAP_REPEAT = 0 # Repeats texture in tiled mode
  TEXTURE_WRAP_CLAMP = 1 # Clamps texture to edge pixel in tiled mode
  TEXTURE_WRAP_MIRROR_REPEAT = 2 # Mirrors and repeats the texture in tiled mode
  TEXTURE_WRAP_MIRROR_CLAMP = 3 # Mirrors and clamps to border the texture in tiled mode

  # enum CubemapLayout
  # Cubemap layouts
  CUBEMAP_LAYOUT_AUTO_DETECT = 0 # Automatically detect layout type
  CUBEMAP_LAYOUT_LINE_VERTICAL = 1 # Layout is defined by a vertical line with faces
  CUBEMAP_LAYOUT_LINE_HORIZONTAL = 2 # Layout is defined by an horizontal line with faces
  CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR = 3 # Layout is defined by a 3x4 cross with cubemap faces
  CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE = 4 # Layout is defined by a 4x3 cross with cubemap faces
  CUBEMAP_LAYOUT_PANORAMA = 5 # Layout is defined by a panorama image (equirectangular map)

  # enum FontType
  # Font type, defines generation method
  FONT_DEFAULT = 0 # Default font generation, anti-aliased
  FONT_BITMAP = 1 # Bitmap font generation, no anti-aliasing
  FONT_SDF = 2 # SDF font generation, requires external shader

  # enum BlendMode
  # Color blending modes (pre-defined)
  BLEND_ALPHA = 0 # Blend textures considering alpha (default)
  BLEND_ADDITIVE = 1 # Blend textures adding colors
  BLEND_MULTIPLIED = 2 # Blend textures multiplying colors
  BLEND_ADD_COLORS = 3 # Blend textures adding colors (alternative)
  BLEND_SUBTRACT_COLORS = 4 # Blend textures subtracting colors (alternative)
  BLEND_ALPHA_PREMULTIPLY = 5 # Blend premultiplied textures considering alpha
  BLEND_CUSTOM = 6 # Blend textures using custom src/dst factors (use rlSetBlendFactors())
  BLEND_CUSTOM_SEPARATE = 7 # Blend textures using custom rgb/alpha separate src/dst factors (use rlSetBlendFactorsSeparate())

  # enum Gesture
  # Gesture
  GESTURE_NONE = 0 # No gesture
  GESTURE_TAP = 1 # Tap gesture
  GESTURE_DOUBLETAP = 2 # Double tap gesture
  GESTURE_HOLD = 4 # Hold gesture
  GESTURE_DRAG = 8 # Drag gesture
  GESTURE_SWIPE_RIGHT = 16 # Swipe right gesture
  GESTURE_SWIPE_LEFT = 32 # Swipe left gesture
  GESTURE_SWIPE_UP = 64 # Swipe up gesture
  GESTURE_SWIPE_DOWN = 128 # Swipe down gesture
  GESTURE_PINCH_IN = 256 # Pinch in gesture
  GESTURE_PINCH_OUT = 512 # Pinch out gesture

  # enum CameraMode
  # Camera system modes
  CAMERA_CUSTOM = 0 # Custom camera
  CAMERA_FREE = 1 # Free camera
  CAMERA_ORBITAL = 2 # Orbital camera
  CAMERA_FIRST_PERSON = 3 # First person camera
  CAMERA_THIRD_PERSON = 4 # Third person camera

  # enum CameraProjection
  # Camera projection
  CAMERA_PERSPECTIVE = 0 # Perspective projection
  CAMERA_ORTHOGRAPHIC = 1 # Orthographic projection

  # enum NPatchLayout
  # N-patch layout
  NPATCH_NINE_PATCH = 0 # Npatch layout: 3x3 tiles
  NPATCH_THREE_PATCH_VERTICAL = 1 # Npatch layout: 1x3 tiles
  NPATCH_THREE_PATCH_HORIZONTAL = 2 # Npatch layout: 3x1 tiles


  # Typedef

  typedef :int, :ConfigFlags
  typedef :int, :TraceLogLevel
  typedef :int, :KeyboardKey
  typedef :int, :MouseButton
  typedef :int, :MouseCursor
  typedef :int, :GamepadButton
  typedef :int, :GamepadAxis
  typedef :int, :MaterialMapIndex
  typedef :int, :ShaderLocationIndex
  typedef :int, :ShaderUniformDataType
  typedef :int, :ShaderAttributeDataType
  typedef :int, :PixelFormat
  typedef :int, :TextureFilter
  typedef :int, :TextureWrap
  typedef :int, :CubemapLayout
  typedef :int, :FontType
  typedef :int, :BlendMode
  typedef :int, :Gesture
  typedef :int, :CameraMode
  typedef :int, :CameraProjection
  typedef :int, :NPatchLayout
  callback :TraceLogCallback, [:int, :pointer, :int], :void
  callback :LoadFileDataCallback, [:pointer, :pointer], :pointer
  callback :SaveFileDataCallback, [:pointer, :pointer, :uint], :bool
  callback :LoadFileTextCallback, [:pointer], :pointer
  callback :SaveFileTextCallback, [:pointer, :pointer], :bool
  callback :AudioCallback, [:pointer, :uint], :void

  # Struct

  # Vector2, 2 components
  class Vector2 < FFI::Struct
    layout(
      :x, :float, # Vector x component
      :y, :float, # Vector y component
    )
  end

  # Vector3, 3 components
  class Vector3 < FFI::Struct
    layout(
      :x, :float, # Vector x component
      :y, :float, # Vector y component
      :z, :float, # Vector z component
    )
  end

  # Vector4, 4 components
  class Vector4 < FFI::Struct
    layout(
      :x, :float, # Vector x component
      :y, :float, # Vector y component
      :z, :float, # Vector z component
      :w, :float, # Vector w component
    )
  end

  Quaternion = Vector4

  # Matrix, 4x4 components, column major, OpenGL style, right handed
  class Matrix < FFI::Struct
    layout(
      :m0, :float, # Matrix first row (4 components)
      :m4, :float, # Matrix first row (4 components)
      :m8, :float, # Matrix first row (4 components)
      :m12, :float, # Matrix first row (4 components)
      :m1, :float, # Matrix second row (4 components)
      :m5, :float, # Matrix second row (4 components)
      :m9, :float, # Matrix second row (4 components)
      :m13, :float, # Matrix second row (4 components)
      :m2, :float, # Matrix third row (4 components)
      :m6, :float, # Matrix third row (4 components)
      :m10, :float, # Matrix third row (4 components)
      :m14, :float, # Matrix third row (4 components)
      :m3, :float, # Matrix fourth row (4 components)
      :m7, :float, # Matrix fourth row (4 components)
      :m11, :float, # Matrix fourth row (4 components)
      :m15, :float, # Matrix fourth row (4 components)
    )
  end

  # Color, 4 components, R8G8B8A8 (32bit)
  class Color < FFI::Struct
    layout(
      :r, :uchar, # Color red value
      :g, :uchar, # Color green value
      :b, :uchar, # Color blue value
      :a, :uchar, # Color alpha value
    )
  end

  # Rectangle, 4 components
  class Rectangle < FFI::Struct
    layout(
      :x, :float, # Rectangle top-left corner position x
      :y, :float, # Rectangle top-left corner position y
      :width, :float, # Rectangle width
      :height, :float, # Rectangle height
    )
  end

  # Image, pixel data stored in CPU memory (RAM)
  class Image < FFI::Struct
    layout(
      :data, :pointer, # Image raw data
      :width, :int, # Image base width
      :height, :int, # Image base height
      :mipmaps, :int, # Mipmap levels, 1 by default
      :format, :int, # Data format (PixelFormat type)
    )
  end

  # Texture, tex data stored in GPU memory (VRAM)
  class Texture < FFI::Struct
    layout(
      :id, :uint, # OpenGL texture id
      :width, :int, # Texture base width
      :height, :int, # Texture base height
      :mipmaps, :int, # Mipmap levels, 1 by default
      :format, :int, # Data format (PixelFormat type)
    )
  end

  Texture2D = Texture
  TextureCubemap = Texture

  # RenderTexture, fbo for texture rendering
  class RenderTexture < FFI::Struct
    layout(
      :id, :uint, # OpenGL framebuffer object id
      :texture, Texture, # Color buffer attachment texture
      :depth, Texture, # Depth buffer attachment texture
    )
  end

  RenderTexture2D = RenderTexture

  # NPatchInfo, n-patch layout info
  class NPatchInfo < FFI::Struct
    layout(
      :source, Rectangle, # Texture source rectangle
      :left, :int, # Left border offset
      :top, :int, # Top border offset
      :right, :int, # Right border offset
      :bottom, :int, # Bottom border offset
      :layout, :int, # Layout of the n-patch: 3x3, 1x3 or 3x1
    )
  end

  # GlyphInfo, font characters glyphs info
  class GlyphInfo < FFI::Struct
    layout(
      :value, :int, # Character value (Unicode)
      :offsetX, :int, # Character offset X when drawing
      :offsetY, :int, # Character offset Y when drawing
      :advanceX, :int, # Character advance position X
      :image, Image, # Character image data
    )
  end

  # Font, font texture and GlyphInfo array data
  class Font < FFI::Struct
    layout(
      :baseSize, :int, # Base size (default chars height)
      :glyphCount, :int, # Number of glyph characters
      :glyphPadding, :int, # Padding around the glyph characters
      :texture, Texture2D, # Texture atlas containing the glyphs
      :recs, :pointer, # Rectangles in texture for the glyphs
      :glyphs, :pointer, # Glyphs info data
    )
  end

  # Camera, defines position/orientation in 3d space
  class Camera3D < FFI::Struct
    layout(
      :position, Vector3, # Camera position
      :target, Vector3, # Camera target it looks-at
      :up, Vector3, # Camera up vector (rotation over its axis)
      :fovy, :float, # Camera field-of-view aperture in Y (degrees) in perspective, used as near plane width in orthographic
      :projection, :int, # Camera projection: CAMERA_PERSPECTIVE or CAMERA_ORTHOGRAPHIC
    )
  end

  Camera = Camera3D

  # Camera2D, defines position/orientation in 2d space
  class Camera2D < FFI::Struct
    layout(
      :offset, Vector2, # Camera offset (displacement from target)
      :target, Vector2, # Camera target (rotation and zoom origin)
      :rotation, :float, # Camera rotation in degrees
      :zoom, :float, # Camera zoom (scaling), should be 1.0f by default
    )
  end

  # Mesh, vertex data and vao/vbo
  class Mesh < FFI::Struct
    layout(
      :vertexCount, :int, # Number of vertices stored in arrays
      :triangleCount, :int, # Number of triangles stored (indexed or not)
      :vertices, :pointer, # Vertex position (XYZ - 3 components per vertex) (shader-location = 0)
      :texcoords, :pointer, # Vertex texture coordinates (UV - 2 components per vertex) (shader-location = 1)
      :texcoords2, :pointer, # Vertex texture second coordinates (UV - 2 components per vertex) (shader-location = 5)
      :normals, :pointer, # Vertex normals (XYZ - 3 components per vertex) (shader-location = 2)
      :tangents, :pointer, # Vertex tangents (XYZW - 4 components per vertex) (shader-location = 4)
      :colors, :pointer, # Vertex colors (RGBA - 4 components per vertex) (shader-location = 3)
      :indices, :pointer, # Vertex indices (in case vertex data comes indexed)
      :animVertices, :pointer, # Animated vertex positions (after bones transformations)
      :animNormals, :pointer, # Animated normals (after bones transformations)
      :boneIds, :pointer, # Vertex bone ids, max 255 bone ids, up to 4 bones influence by vertex (skinning)
      :boneWeights, :pointer, # Vertex bone weight, up to 4 bones influence by vertex (skinning)
      :vaoId, :uint, # OpenGL Vertex Array Object id
      :vboId, :pointer, # OpenGL Vertex Buffer Objects id (default vertex data)
    )
  end

  # Shader
  class Shader < FFI::Struct
    layout(
      :id, :uint, # Shader program id
      :locs, :pointer, # Shader locations array (RL_MAX_SHADER_LOCATIONS)
    )
  end

  # MaterialMap
  class MaterialMap < FFI::Struct
    layout(
      :texture, Texture2D, # Material map texture
      :color, Color, # Material map color
      :value, :float, # Material map value
    )
  end

  # Material, includes shader and maps
  class Material < FFI::Struct
    layout(
      :shader, Shader, # Material shader
      :maps, :pointer, # Material maps array (MAX_MATERIAL_MAPS)
      :params, [:float, 4], # Material generic parameters (if required)
    )
  end

  # Transform, vertex transformation data
  class Transform < FFI::Struct
    layout(
      :translation, Vector3, # Translation
      :rotation, Quaternion, # Rotation
      :scale, Vector3, # Scale
    )
  end

  # Bone, skeletal animation bone
  class BoneInfo < FFI::Struct
    layout(
      :name, [:char, 32], # Bone name
      :parent, :int, # Bone parent
    )
  end

  # Model, meshes, materials and animation data
  class Model < FFI::Struct
    layout(
      :transform, Matrix, # Local transform matrix
      :meshCount, :int, # Number of meshes
      :materialCount, :int, # Number of materials
      :meshes, :pointer, # Meshes array
      :materials, :pointer, # Materials array
      :meshMaterial, :pointer, # Mesh material number
      :boneCount, :int, # Number of bones
      :bones, :pointer, # Bones information (skeleton)
      :bindPose, :pointer, # Bones base transformation (pose)
    )
  end

  # ModelAnimation
  class ModelAnimation < FFI::Struct
    layout(
      :boneCount, :int, # Number of bones
      :frameCount, :int, # Number of animation frames
      :bones, :pointer, # Bones information (skeleton)
      :framePoses, :pointer, # Poses array by frame
    )
  end

  # Ray, ray for raycasting
  class Ray < FFI::Struct
    layout(
      :position, Vector3, # Ray position (origin)
      :direction, Vector3, # Ray direction
    )
  end

  # RayCollision, ray hit information
  class RayCollision < FFI::Struct
    layout(
      :hit, :bool, # Did the ray hit something?
      :distance, :float, # Distance to nearest hit
      :point, Vector3, # Point of nearest hit
      :normal, Vector3, # Surface normal of hit
    )
  end

  # BoundingBox
  class BoundingBox < FFI::Struct
    layout(
      :min, Vector3, # Minimum vertex box-corner
      :max, Vector3, # Maximum vertex box-corner
    )
  end

  # Wave, audio wave data
  class Wave < FFI::Struct
    layout(
      :frameCount, :uint, # Total number of frames (considering channels)
      :sampleRate, :uint, # Frequency (samples per second)
      :sampleSize, :uint, # Bit depth (bits per sample): 8, 16, 32 (24 not supported)
      :channels, :uint, # Number of channels (1-mono, 2-stereo, ...)
      :data, :pointer, # Buffer data pointer
    )
  end

  # AudioStream, custom audio stream
  class AudioStream < FFI::Struct
    layout(
      :buffer, :pointer, # Pointer to internal data used by the audio system
      :processor, :pointer, # Pointer to internal data processor, useful for audio effects
      :sampleRate, :uint, # Frequency (samples per second)
      :sampleSize, :uint, # Bit depth (bits per sample): 8, 16, 32 (24 not supported)
      :channels, :uint, # Number of channels (1-mono, 2-stereo, ...)
    )
  end

  # Sound
  class Sound < FFI::Struct
    layout(
      :stream, AudioStream, # Audio stream
      :frameCount, :uint, # Total number of frames (considering channels)
    )
  end

  # Music, audio stream, anything longer than ~10 seconds should be streamed
  class Music < FFI::Struct
    layout(
      :stream, AudioStream, # Audio stream
      :frameCount, :uint, # Total number of frames (considering channels)
      :looping, :bool, # Music looping enable
      :ctxType, :int, # Type of music context (audio filetype)
      :ctxData, :pointer, # Audio context data, depends on type
    )
  end

  # VrDeviceInfo, Head-Mounted-Display device parameters
  class VrDeviceInfo < FFI::Struct
    layout(
      :hResolution, :int, # Horizontal resolution in pixels
      :vResolution, :int, # Vertical resolution in pixels
      :hScreenSize, :float, # Horizontal size in meters
      :vScreenSize, :float, # Vertical size in meters
      :vScreenCenter, :float, # Screen center in meters
      :eyeToScreenDistance, :float, # Distance between eye and display in meters
      :lensSeparationDistance, :float, # Lens separation distance in meters
      :interpupillaryDistance, :float, # IPD (distance between pupils) in meters
      :lensDistortionValues, [:float, 4], # Lens distortion constant parameters
      :chromaAbCorrection, [:float, 4], # Chromatic aberration correction parameters
    )
  end

  # VrStereoConfig, VR stereo rendering configuration for simulator
  class VrStereoConfig < FFI::Struct
    layout(
      :projection, [Matrix, 2], # VR projection matrices (per eye)
      :viewOffset, [Matrix, 2], # VR view offset matrices (per eye)
      :leftLensCenter, [:float, 2], # VR left lens center
      :rightLensCenter, [:float, 2], # VR right lens center
      :leftScreenCenter, [:float, 2], # VR left screen center
      :rightScreenCenter, [:float, 2], # VR right screen center
      :scale, [:float, 2], # VR distortion scale
      :scaleIn, [:float, 2], # VR distortion scale in
    )
  end

  # File path list
  class FilePathList < FFI::Struct
    layout(
      :capacity, :uint, # Filepaths max entries
      :count, :uint, # Filepaths entries count
      :paths, :pointer, # Filepaths entries
    )
  end


  # Function

  def self.setup_raylib_symbols
    entries = [

      # InitWindow : Initialize window and OpenGL context
      # @param width [int]
      # @param height [int]
      # @param title [const char *]
      # @return [void]
      [:InitWindow, :InitWindow, [:int, :int, :pointer], :void],

      # WindowShouldClose : Check if KEY_ESCAPE pressed or Close icon pressed
      # @return [bool]
      [:WindowShouldClose, :WindowShouldClose, [], :bool],

      # CloseWindow : Close window and unload OpenGL context
      # @return [void]
      [:CloseWindow, :CloseWindow, [], :void],

      # IsWindowReady : Check if window has been initialized successfully
      # @return [bool]
      [:IsWindowReady, :IsWindowReady, [], :bool],

      # IsWindowFullscreen : Check if window is currently fullscreen
      # @return [bool]
      [:IsWindowFullscreen, :IsWindowFullscreen, [], :bool],

      # IsWindowHidden : Check if window is currently hidden (only PLATFORM_DESKTOP)
      # @return [bool]
      [:IsWindowHidden, :IsWindowHidden, [], :bool],

      # IsWindowMinimized : Check if window is currently minimized (only PLATFORM_DESKTOP)
      # @return [bool]
      [:IsWindowMinimized, :IsWindowMinimized, [], :bool],

      # IsWindowMaximized : Check if window is currently maximized (only PLATFORM_DESKTOP)
      # @return [bool]
      [:IsWindowMaximized, :IsWindowMaximized, [], :bool],

      # IsWindowFocused : Check if window is currently focused (only PLATFORM_DESKTOP)
      # @return [bool]
      [:IsWindowFocused, :IsWindowFocused, [], :bool],

      # IsWindowResized : Check if window has been resized last frame
      # @return [bool]
      [:IsWindowResized, :IsWindowResized, [], :bool],

      # IsWindowState : Check if one specific window flag is enabled
      # @param flag [unsigned int]
      # @return [bool]
      [:IsWindowState, :IsWindowState, [:uint], :bool],

      # SetWindowState : Set window configuration state using flags (only PLATFORM_DESKTOP)
      # @param flags [unsigned int]
      # @return [void]
      [:SetWindowState, :SetWindowState, [:uint], :void],

      # ClearWindowState : Clear window configuration state flags
      # @param flags [unsigned int]
      # @return [void]
      [:ClearWindowState, :ClearWindowState, [:uint], :void],

      # ToggleFullscreen : Toggle window state: fullscreen/windowed (only PLATFORM_DESKTOP)
      # @return [void]
      [:ToggleFullscreen, :ToggleFullscreen, [], :void],

      # MaximizeWindow : Set window state: maximized, if resizable (only PLATFORM_DESKTOP)
      # @return [void]
      [:MaximizeWindow, :MaximizeWindow, [], :void],

      # MinimizeWindow : Set window state: minimized, if resizable (only PLATFORM_DESKTOP)
      # @return [void]
      [:MinimizeWindow, :MinimizeWindow, [], :void],

      # RestoreWindow : Set window state: not minimized/maximized (only PLATFORM_DESKTOP)
      # @return [void]
      [:RestoreWindow, :RestoreWindow, [], :void],

      # SetWindowIcon : Set icon for window (only PLATFORM_DESKTOP)
      # @param image [Image]
      # @return [void]
      [:SetWindowIcon, :SetWindowIcon, [Image.by_value], :void],

      # SetWindowTitle : Set title for window (only PLATFORM_DESKTOP)
      # @param title [const char *]
      # @return [void]
      [:SetWindowTitle, :SetWindowTitle, [:pointer], :void],

      # SetWindowPosition : Set window position on screen (only PLATFORM_DESKTOP)
      # @param x [int]
      # @param y [int]
      # @return [void]
      [:SetWindowPosition, :SetWindowPosition, [:int, :int], :void],

      # SetWindowMonitor : Set monitor for the current window (fullscreen mode)
      # @param monitor [int]
      # @return [void]
      [:SetWindowMonitor, :SetWindowMonitor, [:int], :void],

      # SetWindowMinSize : Set window minimum dimensions (for FLAG_WINDOW_RESIZABLE)
      # @param width [int]
      # @param height [int]
      # @return [void]
      [:SetWindowMinSize, :SetWindowMinSize, [:int, :int], :void],

      # SetWindowSize : Set window dimensions
      # @param width [int]
      # @param height [int]
      # @return [void]
      [:SetWindowSize, :SetWindowSize, [:int, :int], :void],

      # SetWindowOpacity : Set window opacity [0.0f..1.0f] (only PLATFORM_DESKTOP)
      # @param opacity [float]
      # @return [void]
      [:SetWindowOpacity, :SetWindowOpacity, [:float], :void],

      # GetWindowHandle : Get native window handle
      # @return [void *]
      [:GetWindowHandle, :GetWindowHandle, [], :pointer],

      # GetScreenWidth : Get current screen width
      # @return [int]
      [:GetScreenWidth, :GetScreenWidth, [], :int],

      # GetScreenHeight : Get current screen height
      # @return [int]
      [:GetScreenHeight, :GetScreenHeight, [], :int],

      # GetRenderWidth : Get current render width (it considers HiDPI)
      # @return [int]
      [:GetRenderWidth, :GetRenderWidth, [], :int],

      # GetRenderHeight : Get current render height (it considers HiDPI)
      # @return [int]
      [:GetRenderHeight, :GetRenderHeight, [], :int],

      # GetMonitorCount : Get number of connected monitors
      # @return [int]
      [:GetMonitorCount, :GetMonitorCount, [], :int],

      # GetCurrentMonitor : Get current connected monitor
      # @return [int]
      [:GetCurrentMonitor, :GetCurrentMonitor, [], :int],

      # GetMonitorPosition : Get specified monitor position
      # @param monitor [int]
      # @return [Vector2]
      [:GetMonitorPosition, :GetMonitorPosition, [:int], Vector2.by_value],

      # GetMonitorWidth : Get specified monitor width (current video mode used by monitor)
      # @param monitor [int]
      # @return [int]
      [:GetMonitorWidth, :GetMonitorWidth, [:int], :int],

      # GetMonitorHeight : Get specified monitor height (current video mode used by monitor)
      # @param monitor [int]
      # @return [int]
      [:GetMonitorHeight, :GetMonitorHeight, [:int], :int],

      # GetMonitorPhysicalWidth : Get specified monitor physical width in millimetres
      # @param monitor [int]
      # @return [int]
      [:GetMonitorPhysicalWidth, :GetMonitorPhysicalWidth, [:int], :int],

      # GetMonitorPhysicalHeight : Get specified monitor physical height in millimetres
      # @param monitor [int]
      # @return [int]
      [:GetMonitorPhysicalHeight, :GetMonitorPhysicalHeight, [:int], :int],

      # GetMonitorRefreshRate : Get specified monitor refresh rate
      # @param monitor [int]
      # @return [int]
      [:GetMonitorRefreshRate, :GetMonitorRefreshRate, [:int], :int],

      # GetWindowPosition : Get window position XY on monitor
      # @return [Vector2]
      [:GetWindowPosition, :GetWindowPosition, [], Vector2.by_value],

      # GetWindowScaleDPI : Get window scale DPI factor
      # @return [Vector2]
      [:GetWindowScaleDPI, :GetWindowScaleDPI, [], Vector2.by_value],

      # GetMonitorName : Get the human-readable, UTF-8 encoded name of the primary monitor
      # @param monitor [int]
      # @return [const char *]
      [:GetMonitorName, :GetMonitorName, [:int], :pointer],

      # SetClipboardText : Set clipboard text content
      # @param text [const char *]
      # @return [void]
      [:SetClipboardText, :SetClipboardText, [:pointer], :void],

      # GetClipboardText : Get clipboard text content
      # @return [const char *]
      [:GetClipboardText, :GetClipboardText, [], :pointer],

      # EnableEventWaiting : Enable waiting for events on EndDrawing(), no automatic event polling
      # @return [void]
      [:EnableEventWaiting, :EnableEventWaiting, [], :void],

      # DisableEventWaiting : Disable waiting for events on EndDrawing(), automatic events polling
      # @return [void]
      [:DisableEventWaiting, :DisableEventWaiting, [], :void],

      # SwapScreenBuffer : Swap back buffer with front buffer (screen drawing)
      # @return [void]
      [:SwapScreenBuffer, :SwapScreenBuffer, [], :void],

      # PollInputEvents : Register all input events
      # @return [void]
      [:PollInputEvents, :PollInputEvents, [], :void],

      # WaitTime : Wait for some time (halt program execution)
      # @param seconds [double]
      # @return [void]
      [:WaitTime, :WaitTime, [:double], :void],

      # ShowCursor : Shows cursor
      # @return [void]
      [:ShowCursor, :ShowCursor, [], :void],

      # HideCursor : Hides cursor
      # @return [void]
      [:HideCursor, :HideCursor, [], :void],

      # IsCursorHidden : Check if cursor is not visible
      # @return [bool]
      [:IsCursorHidden, :IsCursorHidden, [], :bool],

      # EnableCursor : Enables cursor (unlock cursor)
      # @return [void]
      [:EnableCursor, :EnableCursor, [], :void],

      # DisableCursor : Disables cursor (lock cursor)
      # @return [void]
      [:DisableCursor, :DisableCursor, [], :void],

      # IsCursorOnScreen : Check if cursor is on the screen
      # @return [bool]
      [:IsCursorOnScreen, :IsCursorOnScreen, [], :bool],

      # ClearBackground : Set background color (framebuffer clear color)
      # @param color [Color]
      # @return [void]
      [:ClearBackground, :ClearBackground, [Color.by_value], :void],

      # BeginDrawing : Setup canvas (framebuffer) to start drawing
      # @return [void]
      [:BeginDrawing, :BeginDrawing, [], :void],

      # EndDrawing : End canvas drawing and swap buffers (double buffering)
      # @return [void]
      [:EndDrawing, :EndDrawing, [], :void],

      # BeginMode2D : Begin 2D mode with custom camera (2D)
      # @param camera [Camera2D]
      # @return [void]
      [:BeginMode2D, :BeginMode2D, [Camera2D.by_value], :void],

      # EndMode2D : Ends 2D mode with custom camera
      # @return [void]
      [:EndMode2D, :EndMode2D, [], :void],

      # BeginMode3D : Begin 3D mode with custom camera (3D)
      # @param camera [Camera3D]
      # @return [void]
      [:BeginMode3D, :BeginMode3D, [Camera3D.by_value], :void],

      # EndMode3D : Ends 3D mode and returns to default 2D orthographic mode
      # @return [void]
      [:EndMode3D, :EndMode3D, [], :void],

      # BeginTextureMode : Begin drawing to render texture
      # @param target [RenderTexture2D]
      # @return [void]
      [:BeginTextureMode, :BeginTextureMode, [RenderTexture2D.by_value], :void],

      # EndTextureMode : Ends drawing to render texture
      # @return [void]
      [:EndTextureMode, :EndTextureMode, [], :void],

      # BeginShaderMode : Begin custom shader drawing
      # @param shader [Shader]
      # @return [void]
      [:BeginShaderMode, :BeginShaderMode, [Shader.by_value], :void],

      # EndShaderMode : End custom shader drawing (use default shader)
      # @return [void]
      [:EndShaderMode, :EndShaderMode, [], :void],

      # BeginBlendMode : Begin blending mode (alpha, additive, multiplied, subtract, custom)
      # @param mode [int]
      # @return [void]
      [:BeginBlendMode, :BeginBlendMode, [:int], :void],

      # EndBlendMode : End blending mode (reset to default: alpha blending)
      # @return [void]
      [:EndBlendMode, :EndBlendMode, [], :void],

      # BeginScissorMode : Begin scissor mode (define screen area for following drawing)
      # @param x [int]
      # @param y [int]
      # @param width [int]
      # @param height [int]
      # @return [void]
      [:BeginScissorMode, :BeginScissorMode, [:int, :int, :int, :int], :void],

      # EndScissorMode : End scissor mode
      # @return [void]
      [:EndScissorMode, :EndScissorMode, [], :void],

      # BeginVrStereoMode : Begin stereo rendering (requires VR simulator)
      # @param config [VrStereoConfig]
      # @return [void]
      [:BeginVrStereoMode, :BeginVrStereoMode, [VrStereoConfig.by_value], :void],

      # EndVrStereoMode : End stereo rendering (requires VR simulator)
      # @return [void]
      [:EndVrStereoMode, :EndVrStereoMode, [], :void],

      # LoadVrStereoConfig : Load VR stereo config for VR simulator device parameters
      # @param device [VrDeviceInfo]
      # @return [VrStereoConfig]
      [:LoadVrStereoConfig, :LoadVrStereoConfig, [VrDeviceInfo.by_value], VrStereoConfig.by_value],

      # UnloadVrStereoConfig : Unload VR stereo config
      # @param config [VrStereoConfig]
      # @return [void]
      [:UnloadVrStereoConfig, :UnloadVrStereoConfig, [VrStereoConfig.by_value], :void],

      # LoadShader : Load shader from files and bind default locations
      # @param vsFileName [const char *]
      # @param fsFileName [const char *]
      # @return [Shader]
      [:LoadShader, :LoadShader, [:pointer, :pointer], Shader.by_value],

      # LoadShaderFromMemory : Load shader from code strings and bind default locations
      # @param vsCode [const char *]
      # @param fsCode [const char *]
      # @return [Shader]
      [:LoadShaderFromMemory, :LoadShaderFromMemory, [:pointer, :pointer], Shader.by_value],

      # GetShaderLocation : Get shader uniform location
      # @param shader [Shader]
      # @param uniformName [const char *]
      # @return [int]
      [:GetShaderLocation, :GetShaderLocation, [Shader.by_value, :pointer], :int],

      # GetShaderLocationAttrib : Get shader attribute location
      # @param shader [Shader]
      # @param attribName [const char *]
      # @return [int]
      [:GetShaderLocationAttrib, :GetShaderLocationAttrib, [Shader.by_value, :pointer], :int],

      # SetShaderValue : Set shader uniform value
      # @param shader [Shader]
      # @param locIndex [int]
      # @param value [const void *]
      # @param uniformType [int]
      # @return [void]
      [:SetShaderValue, :SetShaderValue, [Shader.by_value, :int, :pointer, :int], :void],

      # SetShaderValueV : Set shader uniform value vector
      # @param shader [Shader]
      # @param locIndex [int]
      # @param value [const void *]
      # @param uniformType [int]
      # @param count [int]
      # @return [void]
      [:SetShaderValueV, :SetShaderValueV, [Shader.by_value, :int, :pointer, :int, :int], :void],

      # SetShaderValueMatrix : Set shader uniform value (matrix 4x4)
      # @param shader [Shader]
      # @param locIndex [int]
      # @param mat [Matrix]
      # @return [void]
      [:SetShaderValueMatrix, :SetShaderValueMatrix, [Shader.by_value, :int, Matrix.by_value], :void],

      # SetShaderValueTexture : Set shader uniform value for texture (sampler2d)
      # @param shader [Shader]
      # @param locIndex [int]
      # @param texture [Texture2D]
      # @return [void]
      [:SetShaderValueTexture, :SetShaderValueTexture, [Shader.by_value, :int, Texture2D.by_value], :void],

      # UnloadShader : Unload shader from GPU memory (VRAM)
      # @param shader [Shader]
      # @return [void]
      [:UnloadShader, :UnloadShader, [Shader.by_value], :void],

      # GetMouseRay : Get a ray trace from mouse position
      # @param mousePosition [Vector2]
      # @param camera [Camera]
      # @return [Ray]
      [:GetMouseRay, :GetMouseRay, [Vector2.by_value, Camera.by_value], Ray.by_value],

      # GetCameraMatrix : Get camera transform matrix (view matrix)
      # @param camera [Camera]
      # @return [Matrix]
      [:GetCameraMatrix, :GetCameraMatrix, [Camera.by_value], Matrix.by_value],

      # GetCameraMatrix2D : Get camera 2d transform matrix
      # @param camera [Camera2D]
      # @return [Matrix]
      [:GetCameraMatrix2D, :GetCameraMatrix2D, [Camera2D.by_value], Matrix.by_value],

      # GetWorldToScreen : Get the screen space position for a 3d world space position
      # @param position [Vector3]
      # @param camera [Camera]
      # @return [Vector2]
      [:GetWorldToScreen, :GetWorldToScreen, [Vector3.by_value, Camera.by_value], Vector2.by_value],

      # GetScreenToWorld2D : Get the world space position for a 2d camera screen space position
      # @param position [Vector2]
      # @param camera [Camera2D]
      # @return [Vector2]
      [:GetScreenToWorld2D, :GetScreenToWorld2D, [Vector2.by_value, Camera2D.by_value], Vector2.by_value],

      # GetWorldToScreenEx : Get size position for a 3d world space position
      # @param position [Vector3]
      # @param camera [Camera]
      # @param width [int]
      # @param height [int]
      # @return [Vector2]
      [:GetWorldToScreenEx, :GetWorldToScreenEx, [Vector3.by_value, Camera.by_value, :int, :int], Vector2.by_value],

      # GetWorldToScreen2D : Get the screen space position for a 2d camera world space position
      # @param position [Vector2]
      # @param camera [Camera2D]
      # @return [Vector2]
      [:GetWorldToScreen2D, :GetWorldToScreen2D, [Vector2.by_value, Camera2D.by_value], Vector2.by_value],

      # SetTargetFPS : Set target FPS (maximum)
      # @param fps [int]
      # @return [void]
      [:SetTargetFPS, :SetTargetFPS, [:int], :void],

      # GetFPS : Get current FPS
      # @return [int]
      [:GetFPS, :GetFPS, [], :int],

      # GetFrameTime : Get time in seconds for last frame drawn (delta time)
      # @return [float]
      [:GetFrameTime, :GetFrameTime, [], :float],

      # GetTime : Get elapsed time in seconds since InitWindow()
      # @return [double]
      [:GetTime, :GetTime, [], :double],

      # GetRandomValue : Get a random value between min and max (both included)
      # @param min [int]
      # @param max [int]
      # @return [int]
      [:GetRandomValue, :GetRandomValue, [:int, :int], :int],

      # SetRandomSeed : Set the seed for the random number generator
      # @param seed [unsigned int]
      # @return [void]
      [:SetRandomSeed, :SetRandomSeed, [:uint], :void],

      # TakeScreenshot : Takes a screenshot of current screen (filename extension defines format)
      # @param fileName [const char *]
      # @return [void]
      [:TakeScreenshot, :TakeScreenshot, [:pointer], :void],

      # SetConfigFlags : Setup init configuration flags (view FLAGS)
      # @param flags [unsigned int]
      # @return [void]
      [:SetConfigFlags, :SetConfigFlags, [:uint], :void],

      # TraceLog : Show trace log messages (LOG_DEBUG, LOG_INFO, LOG_WARNING, LOG_ERROR...)
      # @param logLevel [int]
      # @param text [const char *]
      # @param args [...]
      # @return [void]
      [:TraceLog, :TraceLog, [:int, :pointer, :varargs], :void],

      # SetTraceLogLevel : Set the current threshold (minimum) log level
      # @param logLevel [int]
      # @return [void]
      [:SetTraceLogLevel, :SetTraceLogLevel, [:int], :void],

      # MemAlloc : Internal memory allocator
      # @param size [unsigned int]
      # @return [void *]
      [:MemAlloc, :MemAlloc, [:uint], :pointer],

      # MemRealloc : Internal memory reallocator
      # @param ptr [void *]
      # @param size [unsigned int]
      # @return [void *]
      [:MemRealloc, :MemRealloc, [:pointer, :uint], :pointer],

      # MemFree : Internal memory free
      # @param ptr [void *]
      # @return [void]
      [:MemFree, :MemFree, [:pointer], :void],

      # OpenURL : Open URL with default system browser (if available)
      # @param url [const char *]
      # @return [void]
      [:OpenURL, :OpenURL, [:pointer], :void],

      # SetTraceLogCallback : Set custom trace log
      # @param callback [TraceLogCallback]
      # @return [void]
      [:SetTraceLogCallback, :SetTraceLogCallback, [:TraceLogCallback], :void],

      # SetLoadFileDataCallback : Set custom file binary data loader
      # @param callback [LoadFileDataCallback]
      # @return [void]
      [:SetLoadFileDataCallback, :SetLoadFileDataCallback, [:LoadFileDataCallback], :void],

      # SetSaveFileDataCallback : Set custom file binary data saver
      # @param callback [SaveFileDataCallback]
      # @return [void]
      [:SetSaveFileDataCallback, :SetSaveFileDataCallback, [:SaveFileDataCallback], :void],

      # SetLoadFileTextCallback : Set custom file text data loader
      # @param callback [LoadFileTextCallback]
      # @return [void]
      [:SetLoadFileTextCallback, :SetLoadFileTextCallback, [:LoadFileTextCallback], :void],

      # SetSaveFileTextCallback : Set custom file text data saver
      # @param callback [SaveFileTextCallback]
      # @return [void]
      [:SetSaveFileTextCallback, :SetSaveFileTextCallback, [:SaveFileTextCallback], :void],

      # LoadFileData : Load file data as byte array (read)
      # @param fileName [const char *]
      # @param bytesRead [unsigned int *]
      # @return [unsigned char *]
      [:LoadFileData, :LoadFileData, [:pointer, :pointer], :pointer],

      # UnloadFileData : Unload file data allocated by LoadFileData()
      # @param data [unsigned char *]
      # @return [void]
      [:UnloadFileData, :UnloadFileData, [:pointer], :void],

      # SaveFileData : Save data to file from byte array (write), returns true on success
      # @param fileName [const char *]
      # @param data [void *]
      # @param bytesToWrite [unsigned int]
      # @return [bool]
      [:SaveFileData, :SaveFileData, [:pointer, :pointer, :uint], :bool],

      # ExportDataAsCode : Export data to code (.h), returns true on success
      # @param data [const unsigned char *]
      # @param size [unsigned int]
      # @param fileName [const char *]
      # @return [bool]
      [:ExportDataAsCode, :ExportDataAsCode, [:pointer, :uint, :pointer], :bool],

      # LoadFileText : Load text data from file (read), returns a '\0' terminated string
      # @param fileName [const char *]
      # @return [char *]
      [:LoadFileText, :LoadFileText, [:pointer], :pointer],

      # UnloadFileText : Unload file text data allocated by LoadFileText()
      # @param text [char *]
      # @return [void]
      [:UnloadFileText, :UnloadFileText, [:pointer], :void],

      # SaveFileText : Save text data to file (write), string must be '\0' terminated, returns true on success
      # @param fileName [const char *]
      # @param text [char *]
      # @return [bool]
      [:SaveFileText, :SaveFileText, [:pointer, :pointer], :bool],

      # FileExists : Check if file exists
      # @param fileName [const char *]
      # @return [bool]
      [:FileExists, :FileExists, [:pointer], :bool],

      # DirectoryExists : Check if a directory path exists
      # @param dirPath [const char *]
      # @return [bool]
      [:DirectoryExists, :DirectoryExists, [:pointer], :bool],

      # IsFileExtension : Check file extension (including point: .png, .wav)
      # @param fileName [const char *]
      # @param ext [const char *]
      # @return [bool]
      [:IsFileExtension, :IsFileExtension, [:pointer, :pointer], :bool],

      # GetFileLength : Get file length in bytes (NOTE: GetFileSize() conflicts with windows.h)
      # @param fileName [const char *]
      # @return [int]
      [:GetFileLength, :GetFileLength, [:pointer], :int],

      # GetFileExtension : Get pointer to extension for a filename string (includes dot: '.png')
      # @param fileName [const char *]
      # @return [const char *]
      [:GetFileExtension, :GetFileExtension, [:pointer], :pointer],

      # GetFileName : Get pointer to filename for a path string
      # @param filePath [const char *]
      # @return [const char *]
      [:GetFileName, :GetFileName, [:pointer], :pointer],

      # GetFileNameWithoutExt : Get filename string without extension (uses static string)
      # @param filePath [const char *]
      # @return [const char *]
      [:GetFileNameWithoutExt, :GetFileNameWithoutExt, [:pointer], :pointer],

      # GetDirectoryPath : Get full path for a given fileName with path (uses static string)
      # @param filePath [const char *]
      # @return [const char *]
      [:GetDirectoryPath, :GetDirectoryPath, [:pointer], :pointer],

      # GetPrevDirectoryPath : Get previous directory path for a given path (uses static string)
      # @param dirPath [const char *]
      # @return [const char *]
      [:GetPrevDirectoryPath, :GetPrevDirectoryPath, [:pointer], :pointer],

      # GetWorkingDirectory : Get current working directory (uses static string)
      # @return [const char *]
      [:GetWorkingDirectory, :GetWorkingDirectory, [], :pointer],

      # GetApplicationDirectory : Get the directory if the running application (uses static string)
      # @return [const char *]
      [:GetApplicationDirectory, :GetApplicationDirectory, [], :pointer],

      # ChangeDirectory : Change working directory, return true on success
      # @param dir [const char *]
      # @return [bool]
      [:ChangeDirectory, :ChangeDirectory, [:pointer], :bool],

      # IsPathFile : Check if a given path is a file or a directory
      # @param path [const char *]
      # @return [bool]
      [:IsPathFile, :IsPathFile, [:pointer], :bool],

      # LoadDirectoryFiles : Load directory filepaths
      # @param dirPath [const char *]
      # @return [FilePathList]
      [:LoadDirectoryFiles, :LoadDirectoryFiles, [:pointer], FilePathList.by_value],

      # LoadDirectoryFilesEx : Load directory filepaths with extension filtering and recursive directory scan
      # @param basePath [const char *]
      # @param filter [const char *]
      # @param scanSubdirs [bool]
      # @return [FilePathList]
      [:LoadDirectoryFilesEx, :LoadDirectoryFilesEx, [:pointer, :pointer, :bool], FilePathList.by_value],

      # UnloadDirectoryFiles : Unload filepaths
      # @param files [FilePathList]
      # @return [void]
      [:UnloadDirectoryFiles, :UnloadDirectoryFiles, [FilePathList.by_value], :void],

      # IsFileDropped : Check if a file has been dropped into window
      # @return [bool]
      [:IsFileDropped, :IsFileDropped, [], :bool],

      # LoadDroppedFiles : Load dropped filepaths
      # @return [FilePathList]
      [:LoadDroppedFiles, :LoadDroppedFiles, [], FilePathList.by_value],

      # UnloadDroppedFiles : Unload dropped filepaths
      # @param files [FilePathList]
      # @return [void]
      [:UnloadDroppedFiles, :UnloadDroppedFiles, [FilePathList.by_value], :void],

      # GetFileModTime : Get file modification time (last write time)
      # @param fileName [const char *]
      # @return [long]
      [:GetFileModTime, :GetFileModTime, [:pointer], :long],

      # CompressData : Compress data (DEFLATE algorithm), memory must be MemFree()
      # @param data [const unsigned char *]
      # @param dataSize [int]
      # @param compDataSize [int *]
      # @return [unsigned char *]
      [:CompressData, :CompressData, [:pointer, :int, :pointer], :pointer],

      # DecompressData : Decompress data (DEFLATE algorithm), memory must be MemFree()
      # @param compData [const unsigned char *]
      # @param compDataSize [int]
      # @param dataSize [int *]
      # @return [unsigned char *]
      [:DecompressData, :DecompressData, [:pointer, :int, :pointer], :pointer],

      # EncodeDataBase64 : Encode data to Base64 string, memory must be MemFree()
      # @param data [const unsigned char *]
      # @param dataSize [int]
      # @param outputSize [int *]
      # @return [char *]
      [:EncodeDataBase64, :EncodeDataBase64, [:pointer, :int, :pointer], :pointer],

      # DecodeDataBase64 : Decode Base64 string data, memory must be MemFree()
      # @param data [const unsigned char *]
      # @param outputSize [int *]
      # @return [unsigned char *]
      [:DecodeDataBase64, :DecodeDataBase64, [:pointer, :pointer], :pointer],

      # IsKeyPressed : Check if a key has been pressed once
      # @param key [int]
      # @return [bool]
      [:IsKeyPressed, :IsKeyPressed, [:int], :bool],

      # IsKeyDown : Check if a key is being pressed
      # @param key [int]
      # @return [bool]
      [:IsKeyDown, :IsKeyDown, [:int], :bool],

      # IsKeyReleased : Check if a key has been released once
      # @param key [int]
      # @return [bool]
      [:IsKeyReleased, :IsKeyReleased, [:int], :bool],

      # IsKeyUp : Check if a key is NOT being pressed
      # @param key [int]
      # @return [bool]
      [:IsKeyUp, :IsKeyUp, [:int], :bool],

      # SetExitKey : Set a custom key to exit program (default is ESC)
      # @param key [int]
      # @return [void]
      [:SetExitKey, :SetExitKey, [:int], :void],

      # GetKeyPressed : Get key pressed (keycode), call it multiple times for keys queued, returns 0 when the queue is empty
      # @return [int]
      [:GetKeyPressed, :GetKeyPressed, [], :int],

      # GetCharPressed : Get char pressed (unicode), call it multiple times for chars queued, returns 0 when the queue is empty
      # @return [int]
      [:GetCharPressed, :GetCharPressed, [], :int],

      # IsGamepadAvailable : Check if a gamepad is available
      # @param gamepad [int]
      # @return [bool]
      [:IsGamepadAvailable, :IsGamepadAvailable, [:int], :bool],

      # GetGamepadName : Get gamepad internal name id
      # @param gamepad [int]
      # @return [const char *]
      [:GetGamepadName, :GetGamepadName, [:int], :pointer],

      # IsGamepadButtonPressed : Check if a gamepad button has been pressed once
      # @param gamepad [int]
      # @param button [int]
      # @return [bool]
      [:IsGamepadButtonPressed, :IsGamepadButtonPressed, [:int, :int], :bool],

      # IsGamepadButtonDown : Check if a gamepad button is being pressed
      # @param gamepad [int]
      # @param button [int]
      # @return [bool]
      [:IsGamepadButtonDown, :IsGamepadButtonDown, [:int, :int], :bool],

      # IsGamepadButtonReleased : Check if a gamepad button has been released once
      # @param gamepad [int]
      # @param button [int]
      # @return [bool]
      [:IsGamepadButtonReleased, :IsGamepadButtonReleased, [:int, :int], :bool],

      # IsGamepadButtonUp : Check if a gamepad button is NOT being pressed
      # @param gamepad [int]
      # @param button [int]
      # @return [bool]
      [:IsGamepadButtonUp, :IsGamepadButtonUp, [:int, :int], :bool],

      # GetGamepadButtonPressed : Get the last gamepad button pressed
      # @return [int]
      [:GetGamepadButtonPressed, :GetGamepadButtonPressed, [], :int],

      # GetGamepadAxisCount : Get gamepad axis count for a gamepad
      # @param gamepad [int]
      # @return [int]
      [:GetGamepadAxisCount, :GetGamepadAxisCount, [:int], :int],

      # GetGamepadAxisMovement : Get axis movement value for a gamepad axis
      # @param gamepad [int]
      # @param axis [int]
      # @return [float]
      [:GetGamepadAxisMovement, :GetGamepadAxisMovement, [:int, :int], :float],

      # SetGamepadMappings : Set internal gamepad mappings (SDL_GameControllerDB)
      # @param mappings [const char *]
      # @return [int]
      [:SetGamepadMappings, :SetGamepadMappings, [:pointer], :int],

      # IsMouseButtonPressed : Check if a mouse button has been pressed once
      # @param button [int]
      # @return [bool]
      [:IsMouseButtonPressed, :IsMouseButtonPressed, [:int], :bool],

      # IsMouseButtonDown : Check if a mouse button is being pressed
      # @param button [int]
      # @return [bool]
      [:IsMouseButtonDown, :IsMouseButtonDown, [:int], :bool],

      # IsMouseButtonReleased : Check if a mouse button has been released once
      # @param button [int]
      # @return [bool]
      [:IsMouseButtonReleased, :IsMouseButtonReleased, [:int], :bool],

      # IsMouseButtonUp : Check if a mouse button is NOT being pressed
      # @param button [int]
      # @return [bool]
      [:IsMouseButtonUp, :IsMouseButtonUp, [:int], :bool],

      # GetMouseX : Get mouse position X
      # @return [int]
      [:GetMouseX, :GetMouseX, [], :int],

      # GetMouseY : Get mouse position Y
      # @return [int]
      [:GetMouseY, :GetMouseY, [], :int],

      # GetMousePosition : Get mouse position XY
      # @return [Vector2]
      [:GetMousePosition, :GetMousePosition, [], Vector2.by_value],

      # GetMouseDelta : Get mouse delta between frames
      # @return [Vector2]
      [:GetMouseDelta, :GetMouseDelta, [], Vector2.by_value],

      # SetMousePosition : Set mouse position XY
      # @param x [int]
      # @param y [int]
      # @return [void]
      [:SetMousePosition, :SetMousePosition, [:int, :int], :void],

      # SetMouseOffset : Set mouse offset
      # @param offsetX [int]
      # @param offsetY [int]
      # @return [void]
      [:SetMouseOffset, :SetMouseOffset, [:int, :int], :void],

      # SetMouseScale : Set mouse scaling
      # @param scaleX [float]
      # @param scaleY [float]
      # @return [void]
      [:SetMouseScale, :SetMouseScale, [:float, :float], :void],

      # GetMouseWheelMove : Get mouse wheel movement for X or Y, whichever is larger
      # @return [float]
      [:GetMouseWheelMove, :GetMouseWheelMove, [], :float],

      # GetMouseWheelMoveV : Get mouse wheel movement for both X and Y
      # @return [Vector2]
      [:GetMouseWheelMoveV, :GetMouseWheelMoveV, [], Vector2.by_value],

      # SetMouseCursor : Set mouse cursor
      # @param cursor [int]
      # @return [void]
      [:SetMouseCursor, :SetMouseCursor, [:int], :void],

      # GetTouchX : Get touch position X for touch point 0 (relative to screen size)
      # @return [int]
      [:GetTouchX, :GetTouchX, [], :int],

      # GetTouchY : Get touch position Y for touch point 0 (relative to screen size)
      # @return [int]
      [:GetTouchY, :GetTouchY, [], :int],

      # GetTouchPosition : Get touch position XY for a touch point index (relative to screen size)
      # @param index [int]
      # @return [Vector2]
      [:GetTouchPosition, :GetTouchPosition, [:int], Vector2.by_value],

      # GetTouchPointId : Get touch point identifier for given index
      # @param index [int]
      # @return [int]
      [:GetTouchPointId, :GetTouchPointId, [:int], :int],

      # GetTouchPointCount : Get number of touch points
      # @return [int]
      [:GetTouchPointCount, :GetTouchPointCount, [], :int],

      # SetGesturesEnabled : Enable a set of gestures using flags
      # @param flags [unsigned int]
      # @return [void]
      [:SetGesturesEnabled, :SetGesturesEnabled, [:uint], :void],

      # IsGestureDetected : Check if a gesture have been detected
      # @param gesture [int]
      # @return [bool]
      [:IsGestureDetected, :IsGestureDetected, [:int], :bool],

      # GetGestureDetected : Get latest detected gesture
      # @return [int]
      [:GetGestureDetected, :GetGestureDetected, [], :int],

      # GetGestureHoldDuration : Get gesture hold time in milliseconds
      # @return [float]
      [:GetGestureHoldDuration, :GetGestureHoldDuration, [], :float],

      # GetGestureDragVector : Get gesture drag vector
      # @return [Vector2]
      [:GetGestureDragVector, :GetGestureDragVector, [], Vector2.by_value],

      # GetGestureDragAngle : Get gesture drag angle
      # @return [float]
      [:GetGestureDragAngle, :GetGestureDragAngle, [], :float],

      # GetGesturePinchVector : Get gesture pinch delta
      # @return [Vector2]
      [:GetGesturePinchVector, :GetGesturePinchVector, [], Vector2.by_value],

      # GetGesturePinchAngle : Get gesture pinch angle
      # @return [float]
      [:GetGesturePinchAngle, :GetGesturePinchAngle, [], :float],

      # SetCameraMode : Set camera mode (multiple camera modes available)
      # @param camera [Camera]
      # @param mode [int]
      # @return [void]
      [:SetCameraMode, :SetCameraMode, [Camera.by_value, :int], :void],

      # UpdateCamera : Update camera position for selected mode
      # @param camera [Camera *]
      # @return [void]
      [:UpdateCamera, :UpdateCamera, [:pointer], :void],

      # SetCameraPanControl : Set camera pan key to combine with mouse movement (free camera)
      # @param keyPan [int]
      # @return [void]
      [:SetCameraPanControl, :SetCameraPanControl, [:int], :void],

      # SetCameraAltControl : Set camera alt key to combine with mouse movement (free camera)
      # @param keyAlt [int]
      # @return [void]
      [:SetCameraAltControl, :SetCameraAltControl, [:int], :void],

      # SetCameraSmoothZoomControl : Set camera smooth zoom key to combine with mouse (free camera)
      # @param keySmoothZoom [int]
      # @return [void]
      [:SetCameraSmoothZoomControl, :SetCameraSmoothZoomControl, [:int], :void],

      # SetCameraMoveControls : Set camera move controls (1st person and 3rd person cameras)
      # @param keyFront [int]
      # @param keyBack [int]
      # @param keyRight [int]
      # @param keyLeft [int]
      # @param keyUp [int]
      # @param keyDown [int]
      # @return [void]
      [:SetCameraMoveControls, :SetCameraMoveControls, [:int, :int, :int, :int, :int, :int], :void],

      # SetShapesTexture : Set texture and rectangle to be used on shapes drawing
      # @param texture [Texture2D]
      # @param source [Rectangle]
      # @return [void]
      [:SetShapesTexture, :SetShapesTexture, [Texture2D.by_value, Rectangle.by_value], :void],

      # DrawPixel : Draw a pixel
      # @param posX [int]
      # @param posY [int]
      # @param color [Color]
      # @return [void]
      [:DrawPixel, :DrawPixel, [:int, :int, Color.by_value], :void],

      # DrawPixelV : Draw a pixel (Vector version)
      # @param position [Vector2]
      # @param color [Color]
      # @return [void]
      [:DrawPixelV, :DrawPixelV, [Vector2.by_value, Color.by_value], :void],

      # DrawLine : Draw a line
      # @param startPosX [int]
      # @param startPosY [int]
      # @param endPosX [int]
      # @param endPosY [int]
      # @param color [Color]
      # @return [void]
      [:DrawLine, :DrawLine, [:int, :int, :int, :int, Color.by_value], :void],

      # DrawLineV : Draw a line (Vector version)
      # @param startPos [Vector2]
      # @param endPos [Vector2]
      # @param color [Color]
      # @return [void]
      [:DrawLineV, :DrawLineV, [Vector2.by_value, Vector2.by_value, Color.by_value], :void],

      # DrawLineEx : Draw a line defining thickness
      # @param startPos [Vector2]
      # @param endPos [Vector2]
      # @param thick [float]
      # @param color [Color]
      # @return [void]
      [:DrawLineEx, :DrawLineEx, [Vector2.by_value, Vector2.by_value, :float, Color.by_value], :void],

      # DrawLineBezier : Draw a line using cubic-bezier curves in-out
      # @param startPos [Vector2]
      # @param endPos [Vector2]
      # @param thick [float]
      # @param color [Color]
      # @return [void]
      [:DrawLineBezier, :DrawLineBezier, [Vector2.by_value, Vector2.by_value, :float, Color.by_value], :void],

      # DrawLineBezierQuad : Draw line using quadratic bezier curves with a control point
      # @param startPos [Vector2]
      # @param endPos [Vector2]
      # @param controlPos [Vector2]
      # @param thick [float]
      # @param color [Color]
      # @return [void]
      [:DrawLineBezierQuad, :DrawLineBezierQuad, [Vector2.by_value, Vector2.by_value, Vector2.by_value, :float, Color.by_value], :void],

      # DrawLineBezierCubic : Draw line using cubic bezier curves with 2 control points
      # @param startPos [Vector2]
      # @param endPos [Vector2]
      # @param startControlPos [Vector2]
      # @param endControlPos [Vector2]
      # @param thick [float]
      # @param color [Color]
      # @return [void]
      [:DrawLineBezierCubic, :DrawLineBezierCubic, [Vector2.by_value, Vector2.by_value, Vector2.by_value, Vector2.by_value, :float, Color.by_value], :void],

      # DrawLineStrip : Draw lines sequence
      # @param points [Vector2 *]
      # @param pointCount [int]
      # @param color [Color]
      # @return [void]
      [:DrawLineStrip, :DrawLineStrip, [:pointer, :int, Color.by_value], :void],

      # DrawCircle : Draw a color-filled circle
      # @param centerX [int]
      # @param centerY [int]
      # @param radius [float]
      # @param color [Color]
      # @return [void]
      [:DrawCircle, :DrawCircle, [:int, :int, :float, Color.by_value], :void],

      # DrawCircleSector : Draw a piece of a circle
      # @param center [Vector2]
      # @param radius [float]
      # @param startAngle [float]
      # @param endAngle [float]
      # @param segments [int]
      # @param color [Color]
      # @return [void]
      [:DrawCircleSector, :DrawCircleSector, [Vector2.by_value, :float, :float, :float, :int, Color.by_value], :void],

      # DrawCircleSectorLines : Draw circle sector outline
      # @param center [Vector2]
      # @param radius [float]
      # @param startAngle [float]
      # @param endAngle [float]
      # @param segments [int]
      # @param color [Color]
      # @return [void]
      [:DrawCircleSectorLines, :DrawCircleSectorLines, [Vector2.by_value, :float, :float, :float, :int, Color.by_value], :void],

      # DrawCircleGradient : Draw a gradient-filled circle
      # @param centerX [int]
      # @param centerY [int]
      # @param radius [float]
      # @param color1 [Color]
      # @param color2 [Color]
      # @return [void]
      [:DrawCircleGradient, :DrawCircleGradient, [:int, :int, :float, Color.by_value, Color.by_value], :void],

      # DrawCircleV : Draw a color-filled circle (Vector version)
      # @param center [Vector2]
      # @param radius [float]
      # @param color [Color]
      # @return [void]
      [:DrawCircleV, :DrawCircleV, [Vector2.by_value, :float, Color.by_value], :void],

      # DrawCircleLines : Draw circle outline
      # @param centerX [int]
      # @param centerY [int]
      # @param radius [float]
      # @param color [Color]
      # @return [void]
      [:DrawCircleLines, :DrawCircleLines, [:int, :int, :float, Color.by_value], :void],

      # DrawEllipse : Draw ellipse
      # @param centerX [int]
      # @param centerY [int]
      # @param radiusH [float]
      # @param radiusV [float]
      # @param color [Color]
      # @return [void]
      [:DrawEllipse, :DrawEllipse, [:int, :int, :float, :float, Color.by_value], :void],

      # DrawEllipseLines : Draw ellipse outline
      # @param centerX [int]
      # @param centerY [int]
      # @param radiusH [float]
      # @param radiusV [float]
      # @param color [Color]
      # @return [void]
      [:DrawEllipseLines, :DrawEllipseLines, [:int, :int, :float, :float, Color.by_value], :void],

      # DrawRing : Draw ring
      # @param center [Vector2]
      # @param innerRadius [float]
      # @param outerRadius [float]
      # @param startAngle [float]
      # @param endAngle [float]
      # @param segments [int]
      # @param color [Color]
      # @return [void]
      [:DrawRing, :DrawRing, [Vector2.by_value, :float, :float, :float, :float, :int, Color.by_value], :void],

      # DrawRingLines : Draw ring outline
      # @param center [Vector2]
      # @param innerRadius [float]
      # @param outerRadius [float]
      # @param startAngle [float]
      # @param endAngle [float]
      # @param segments [int]
      # @param color [Color]
      # @return [void]
      [:DrawRingLines, :DrawRingLines, [Vector2.by_value, :float, :float, :float, :float, :int, Color.by_value], :void],

      # DrawRectangle : Draw a color-filled rectangle
      # @param posX [int]
      # @param posY [int]
      # @param width [int]
      # @param height [int]
      # @param color [Color]
      # @return [void]
      [:DrawRectangle, :DrawRectangle, [:int, :int, :int, :int, Color.by_value], :void],

      # DrawRectangleV : Draw a color-filled rectangle (Vector version)
      # @param position [Vector2]
      # @param size [Vector2]
      # @param color [Color]
      # @return [void]
      [:DrawRectangleV, :DrawRectangleV, [Vector2.by_value, Vector2.by_value, Color.by_value], :void],

      # DrawRectangleRec : Draw a color-filled rectangle
      # @param rec [Rectangle]
      # @param color [Color]
      # @return [void]
      [:DrawRectangleRec, :DrawRectangleRec, [Rectangle.by_value, Color.by_value], :void],

      # DrawRectanglePro : Draw a color-filled rectangle with pro parameters
      # @param rec [Rectangle]
      # @param origin [Vector2]
      # @param rotation [float]
      # @param color [Color]
      # @return [void]
      [:DrawRectanglePro, :DrawRectanglePro, [Rectangle.by_value, Vector2.by_value, :float, Color.by_value], :void],

      # DrawRectangleGradientV : Draw a vertical-gradient-filled rectangle
      # @param posX [int]
      # @param posY [int]
      # @param width [int]
      # @param height [int]
      # @param color1 [Color]
      # @param color2 [Color]
      # @return [void]
      [:DrawRectangleGradientV, :DrawRectangleGradientV, [:int, :int, :int, :int, Color.by_value, Color.by_value], :void],

      # DrawRectangleGradientH : Draw a horizontal-gradient-filled rectangle
      # @param posX [int]
      # @param posY [int]
      # @param width [int]
      # @param height [int]
      # @param color1 [Color]
      # @param color2 [Color]
      # @return [void]
      [:DrawRectangleGradientH, :DrawRectangleGradientH, [:int, :int, :int, :int, Color.by_value, Color.by_value], :void],

      # DrawRectangleGradientEx : Draw a gradient-filled rectangle with custom vertex colors
      # @param rec [Rectangle]
      # @param col1 [Color]
      # @param col2 [Color]
      # @param col3 [Color]
      # @param col4 [Color]
      # @return [void]
      [:DrawRectangleGradientEx, :DrawRectangleGradientEx, [Rectangle.by_value, Color.by_value, Color.by_value, Color.by_value, Color.by_value], :void],

      # DrawRectangleLines : Draw rectangle outline
      # @param posX [int]
      # @param posY [int]
      # @param width [int]
      # @param height [int]
      # @param color [Color]
      # @return [void]
      [:DrawRectangleLines, :DrawRectangleLines, [:int, :int, :int, :int, Color.by_value], :void],

      # DrawRectangleLinesEx : Draw rectangle outline with extended parameters
      # @param rec [Rectangle]
      # @param lineThick [float]
      # @param color [Color]
      # @return [void]
      [:DrawRectangleLinesEx, :DrawRectangleLinesEx, [Rectangle.by_value, :float, Color.by_value], :void],

      # DrawRectangleRounded : Draw rectangle with rounded edges
      # @param rec [Rectangle]
      # @param roundness [float]
      # @param segments [int]
      # @param color [Color]
      # @return [void]
      [:DrawRectangleRounded, :DrawRectangleRounded, [Rectangle.by_value, :float, :int, Color.by_value], :void],

      # DrawRectangleRoundedLines : Draw rectangle with rounded edges outline
      # @param rec [Rectangle]
      # @param roundness [float]
      # @param segments [int]
      # @param lineThick [float]
      # @param color [Color]
      # @return [void]
      [:DrawRectangleRoundedLines, :DrawRectangleRoundedLines, [Rectangle.by_value, :float, :int, :float, Color.by_value], :void],

      # DrawTriangle : Draw a color-filled triangle (vertex in counter-clockwise order!)
      # @param v1 [Vector2]
      # @param v2 [Vector2]
      # @param v3 [Vector2]
      # @param color [Color]
      # @return [void]
      [:DrawTriangle, :DrawTriangle, [Vector2.by_value, Vector2.by_value, Vector2.by_value, Color.by_value], :void],

      # DrawTriangleLines : Draw triangle outline (vertex in counter-clockwise order!)
      # @param v1 [Vector2]
      # @param v2 [Vector2]
      # @param v3 [Vector2]
      # @param color [Color]
      # @return [void]
      [:DrawTriangleLines, :DrawTriangleLines, [Vector2.by_value, Vector2.by_value, Vector2.by_value, Color.by_value], :void],

      # DrawTriangleFan : Draw a triangle fan defined by points (first vertex is the center)
      # @param points [Vector2 *]
      # @param pointCount [int]
      # @param color [Color]
      # @return [void]
      [:DrawTriangleFan, :DrawTriangleFan, [:pointer, :int, Color.by_value], :void],

      # DrawTriangleStrip : Draw a triangle strip defined by points
      # @param points [Vector2 *]
      # @param pointCount [int]
      # @param color [Color]
      # @return [void]
      [:DrawTriangleStrip, :DrawTriangleStrip, [:pointer, :int, Color.by_value], :void],

      # DrawPoly : Draw a regular polygon (Vector version)
      # @param center [Vector2]
      # @param sides [int]
      # @param radius [float]
      # @param rotation [float]
      # @param color [Color]
      # @return [void]
      [:DrawPoly, :DrawPoly, [Vector2.by_value, :int, :float, :float, Color.by_value], :void],

      # DrawPolyLines : Draw a polygon outline of n sides
      # @param center [Vector2]
      # @param sides [int]
      # @param radius [float]
      # @param rotation [float]
      # @param color [Color]
      # @return [void]
      [:DrawPolyLines, :DrawPolyLines, [Vector2.by_value, :int, :float, :float, Color.by_value], :void],

      # DrawPolyLinesEx : Draw a polygon outline of n sides with extended parameters
      # @param center [Vector2]
      # @param sides [int]
      # @param radius [float]
      # @param rotation [float]
      # @param lineThick [float]
      # @param color [Color]
      # @return [void]
      [:DrawPolyLinesEx, :DrawPolyLinesEx, [Vector2.by_value, :int, :float, :float, :float, Color.by_value], :void],

      # CheckCollisionRecs : Check collision between two rectangles
      # @param rec1 [Rectangle]
      # @param rec2 [Rectangle]
      # @return [bool]
      [:CheckCollisionRecs, :CheckCollisionRecs, [Rectangle.by_value, Rectangle.by_value], :bool],

      # CheckCollisionCircles : Check collision between two circles
      # @param center1 [Vector2]
      # @param radius1 [float]
      # @param center2 [Vector2]
      # @param radius2 [float]
      # @return [bool]
      [:CheckCollisionCircles, :CheckCollisionCircles, [Vector2.by_value, :float, Vector2.by_value, :float], :bool],

      # CheckCollisionCircleRec : Check collision between circle and rectangle
      # @param center [Vector2]
      # @param radius [float]
      # @param rec [Rectangle]
      # @return [bool]
      [:CheckCollisionCircleRec, :CheckCollisionCircleRec, [Vector2.by_value, :float, Rectangle.by_value], :bool],

      # CheckCollisionPointRec : Check if point is inside rectangle
      # @param point [Vector2]
      # @param rec [Rectangle]
      # @return [bool]
      [:CheckCollisionPointRec, :CheckCollisionPointRec, [Vector2.by_value, Rectangle.by_value], :bool],

      # CheckCollisionPointCircle : Check if point is inside circle
      # @param point [Vector2]
      # @param center [Vector2]
      # @param radius [float]
      # @return [bool]
      [:CheckCollisionPointCircle, :CheckCollisionPointCircle, [Vector2.by_value, Vector2.by_value, :float], :bool],

      # CheckCollisionPointTriangle : Check if point is inside a triangle
      # @param point [Vector2]
      # @param p1 [Vector2]
      # @param p2 [Vector2]
      # @param p3 [Vector2]
      # @return [bool]
      [:CheckCollisionPointTriangle, :CheckCollisionPointTriangle, [Vector2.by_value, Vector2.by_value, Vector2.by_value, Vector2.by_value], :bool],

      # CheckCollisionPointPoly : Check if point is within a polygon described by array of vertices
      # @param point [Vector2]
      # @param points [Vector2 *]
      # @param pointCount [int]
      # @return [bool]
      [:CheckCollisionPointPoly, :CheckCollisionPointPoly, [Vector2.by_value, :pointer, :int], :bool],

      # CheckCollisionLines : Check the collision between two lines defined by two points each, returns collision point by reference
      # @param startPos1 [Vector2]
      # @param endPos1 [Vector2]
      # @param startPos2 [Vector2]
      # @param endPos2 [Vector2]
      # @param collisionPoint [Vector2 *]
      # @return [bool]
      [:CheckCollisionLines, :CheckCollisionLines, [Vector2.by_value, Vector2.by_value, Vector2.by_value, Vector2.by_value, :pointer], :bool],

      # CheckCollisionPointLine : Check if point belongs to line created between two points [p1] and [p2] with defined margin in pixels [threshold]
      # @param point [Vector2]
      # @param p1 [Vector2]
      # @param p2 [Vector2]
      # @param threshold [int]
      # @return [bool]
      [:CheckCollisionPointLine, :CheckCollisionPointLine, [Vector2.by_value, Vector2.by_value, Vector2.by_value, :int], :bool],

      # GetCollisionRec : Get collision rectangle for two rectangles collision
      # @param rec1 [Rectangle]
      # @param rec2 [Rectangle]
      # @return [Rectangle]
      [:GetCollisionRec, :GetCollisionRec, [Rectangle.by_value, Rectangle.by_value], Rectangle.by_value],

      # LoadImage : Load image from file into CPU memory (RAM)
      # @param fileName [const char *]
      # @return [Image]
      [:LoadImage, :LoadImage, [:pointer], Image.by_value],

      # LoadImageRaw : Load image from RAW file data
      # @param fileName [const char *]
      # @param width [int]
      # @param height [int]
      # @param format [int]
      # @param headerSize [int]
      # @return [Image]
      [:LoadImageRaw, :LoadImageRaw, [:pointer, :int, :int, :int, :int], Image.by_value],

      # LoadImageAnim : Load image sequence from file (frames appended to image.data)
      # @param fileName [const char *]
      # @param frames [int *]
      # @return [Image]
      [:LoadImageAnim, :LoadImageAnim, [:pointer, :pointer], Image.by_value],

      # LoadImageFromMemory : Load image from memory buffer, fileType refers to extension: i.e. '.png'
      # @param fileType [const char *]
      # @param fileData [const unsigned char *]
      # @param dataSize [int]
      # @return [Image]
      [:LoadImageFromMemory, :LoadImageFromMemory, [:pointer, :pointer, :int], Image.by_value],

      # LoadImageFromTexture : Load image from GPU texture data
      # @param texture [Texture2D]
      # @return [Image]
      [:LoadImageFromTexture, :LoadImageFromTexture, [Texture2D.by_value], Image.by_value],

      # LoadImageFromScreen : Load image from screen buffer and (screenshot)
      # @return [Image]
      [:LoadImageFromScreen, :LoadImageFromScreen, [], Image.by_value],

      # UnloadImage : Unload image from CPU memory (RAM)
      # @param image [Image]
      # @return [void]
      [:UnloadImage, :UnloadImage, [Image.by_value], :void],

      # ExportImage : Export image data to file, returns true on success
      # @param image [Image]
      # @param fileName [const char *]
      # @return [bool]
      [:ExportImage, :ExportImage, [Image.by_value, :pointer], :bool],

      # ExportImageAsCode : Export image as code file defining an array of bytes, returns true on success
      # @param image [Image]
      # @param fileName [const char *]
      # @return [bool]
      [:ExportImageAsCode, :ExportImageAsCode, [Image.by_value, :pointer], :bool],

      # GenImageColor : Generate image: plain color
      # @param width [int]
      # @param height [int]
      # @param color [Color]
      # @return [Image]
      [:GenImageColor, :GenImageColor, [:int, :int, Color.by_value], Image.by_value],

      # GenImageGradientV : Generate image: vertical gradient
      # @param width [int]
      # @param height [int]
      # @param top [Color]
      # @param bottom [Color]
      # @return [Image]
      [:GenImageGradientV, :GenImageGradientV, [:int, :int, Color.by_value, Color.by_value], Image.by_value],

      # GenImageGradientH : Generate image: horizontal gradient
      # @param width [int]
      # @param height [int]
      # @param left [Color]
      # @param right [Color]
      # @return [Image]
      [:GenImageGradientH, :GenImageGradientH, [:int, :int, Color.by_value, Color.by_value], Image.by_value],

      # GenImageGradientRadial : Generate image: radial gradient
      # @param width [int]
      # @param height [int]
      # @param density [float]
      # @param inner [Color]
      # @param outer [Color]
      # @return [Image]
      [:GenImageGradientRadial, :GenImageGradientRadial, [:int, :int, :float, Color.by_value, Color.by_value], Image.by_value],

      # GenImageChecked : Generate image: checked
      # @param width [int]
      # @param height [int]
      # @param checksX [int]
      # @param checksY [int]
      # @param col1 [Color]
      # @param col2 [Color]
      # @return [Image]
      [:GenImageChecked, :GenImageChecked, [:int, :int, :int, :int, Color.by_value, Color.by_value], Image.by_value],

      # GenImageWhiteNoise : Generate image: white noise
      # @param width [int]
      # @param height [int]
      # @param factor [float]
      # @return [Image]
      [:GenImageWhiteNoise, :GenImageWhiteNoise, [:int, :int, :float], Image.by_value],

      # GenImagePerlinNoise : Generate image: perlin noise
      # @param width [int]
      # @param height [int]
      # @param offsetX [int]
      # @param offsetY [int]
      # @param scale [float]
      # @return [Image]
      [:GenImagePerlinNoise, :GenImagePerlinNoise, [:int, :int, :int, :int, :float], Image.by_value],

      # GenImageCellular : Generate image: cellular algorithm, bigger tileSize means bigger cells
      # @param width [int]
      # @param height [int]
      # @param tileSize [int]
      # @return [Image]
      [:GenImageCellular, :GenImageCellular, [:int, :int, :int], Image.by_value],

      # GenImageText : Generate image: grayscale image from text data
      # @param width [int]
      # @param height [int]
      # @param text [const char *]
      # @return [Image]
      [:GenImageText, :GenImageText, [:int, :int, :pointer], Image.by_value],

      # ImageCopy : Create an image duplicate (useful for transformations)
      # @param image [Image]
      # @return [Image]
      [:ImageCopy, :ImageCopy, [Image.by_value], Image.by_value],

      # ImageFromImage : Create an image from another image piece
      # @param image [Image]
      # @param rec [Rectangle]
      # @return [Image]
      [:ImageFromImage, :ImageFromImage, [Image.by_value, Rectangle.by_value], Image.by_value],

      # ImageText : Create an image from text (default font)
      # @param text [const char *]
      # @param fontSize [int]
      # @param color [Color]
      # @return [Image]
      [:ImageText, :ImageText, [:pointer, :int, Color.by_value], Image.by_value],

      # ImageTextEx : Create an image from text (custom sprite font)
      # @param font [Font]
      # @param text [const char *]
      # @param fontSize [float]
      # @param spacing [float]
      # @param tint [Color]
      # @return [Image]
      [:ImageTextEx, :ImageTextEx, [Font.by_value, :pointer, :float, :float, Color.by_value], Image.by_value],

      # ImageFormat : Convert image data to desired format
      # @param image [Image *]
      # @param newFormat [int]
      # @return [void]
      [:ImageFormat, :ImageFormat, [:pointer, :int], :void],

      # ImageToPOT : Convert image to POT (power-of-two)
      # @param image [Image *]
      # @param fill [Color]
      # @return [void]
      [:ImageToPOT, :ImageToPOT, [:pointer, Color.by_value], :void],

      # ImageCrop : Crop an image to a defined rectangle
      # @param image [Image *]
      # @param crop [Rectangle]
      # @return [void]
      [:ImageCrop, :ImageCrop, [:pointer, Rectangle.by_value], :void],

      # ImageAlphaCrop : Crop image depending on alpha value
      # @param image [Image *]
      # @param threshold [float]
      # @return [void]
      [:ImageAlphaCrop, :ImageAlphaCrop, [:pointer, :float], :void],

      # ImageAlphaClear : Clear alpha channel to desired color
      # @param image [Image *]
      # @param color [Color]
      # @param threshold [float]
      # @return [void]
      [:ImageAlphaClear, :ImageAlphaClear, [:pointer, Color.by_value, :float], :void],

      # ImageAlphaMask : Apply alpha mask to image
      # @param image [Image *]
      # @param alphaMask [Image]
      # @return [void]
      [:ImageAlphaMask, :ImageAlphaMask, [:pointer, Image.by_value], :void],

      # ImageAlphaPremultiply : Premultiply alpha channel
      # @param image [Image *]
      # @return [void]
      [:ImageAlphaPremultiply, :ImageAlphaPremultiply, [:pointer], :void],

      # ImageBlurGaussian : Apply Gaussian blur using a box blur approximation
      # @param image [Image *]
      # @param blurSize [int]
      # @return [void]
      [:ImageBlurGaussian, :ImageBlurGaussian, [:pointer, :int], :void],

      # ImageResize : Resize image (Bicubic scaling algorithm)
      # @param image [Image *]
      # @param newWidth [int]
      # @param newHeight [int]
      # @return [void]
      [:ImageResize, :ImageResize, [:pointer, :int, :int], :void],

      # ImageResizeNN : Resize image (Nearest-Neighbor scaling algorithm)
      # @param image [Image *]
      # @param newWidth [int]
      # @param newHeight [int]
      # @return [void]
      [:ImageResizeNN, :ImageResizeNN, [:pointer, :int, :int], :void],

      # ImageResizeCanvas : Resize canvas and fill with color
      # @param image [Image *]
      # @param newWidth [int]
      # @param newHeight [int]
      # @param offsetX [int]
      # @param offsetY [int]
      # @param fill [Color]
      # @return [void]
      [:ImageResizeCanvas, :ImageResizeCanvas, [:pointer, :int, :int, :int, :int, Color.by_value], :void],

      # ImageMipmaps : Compute all mipmap levels for a provided image
      # @param image [Image *]
      # @return [void]
      [:ImageMipmaps, :ImageMipmaps, [:pointer], :void],

      # ImageDither : Dither image data to 16bpp or lower (Floyd-Steinberg dithering)
      # @param image [Image *]
      # @param rBpp [int]
      # @param gBpp [int]
      # @param bBpp [int]
      # @param aBpp [int]
      # @return [void]
      [:ImageDither, :ImageDither, [:pointer, :int, :int, :int, :int], :void],

      # ImageFlipVertical : Flip image vertically
      # @param image [Image *]
      # @return [void]
      [:ImageFlipVertical, :ImageFlipVertical, [:pointer], :void],

      # ImageFlipHorizontal : Flip image horizontally
      # @param image [Image *]
      # @return [void]
      [:ImageFlipHorizontal, :ImageFlipHorizontal, [:pointer], :void],

      # ImageRotateCW : Rotate image clockwise 90deg
      # @param image [Image *]
      # @return [void]
      [:ImageRotateCW, :ImageRotateCW, [:pointer], :void],

      # ImageRotateCCW : Rotate image counter-clockwise 90deg
      # @param image [Image *]
      # @return [void]
      [:ImageRotateCCW, :ImageRotateCCW, [:pointer], :void],

      # ImageColorTint : Modify image color: tint
      # @param image [Image *]
      # @param color [Color]
      # @return [void]
      [:ImageColorTint, :ImageColorTint, [:pointer, Color.by_value], :void],

      # ImageColorInvert : Modify image color: invert
      # @param image [Image *]
      # @return [void]
      [:ImageColorInvert, :ImageColorInvert, [:pointer], :void],

      # ImageColorGrayscale : Modify image color: grayscale
      # @param image [Image *]
      # @return [void]
      [:ImageColorGrayscale, :ImageColorGrayscale, [:pointer], :void],

      # ImageColorContrast : Modify image color: contrast (-100 to 100)
      # @param image [Image *]
      # @param contrast [float]
      # @return [void]
      [:ImageColorContrast, :ImageColorContrast, [:pointer, :float], :void],

      # ImageColorBrightness : Modify image color: brightness (-255 to 255)
      # @param image [Image *]
      # @param brightness [int]
      # @return [void]
      [:ImageColorBrightness, :ImageColorBrightness, [:pointer, :int], :void],

      # ImageColorReplace : Modify image color: replace color
      # @param image [Image *]
      # @param color [Color]
      # @param replace [Color]
      # @return [void]
      [:ImageColorReplace, :ImageColorReplace, [:pointer, Color.by_value, Color.by_value], :void],

      # LoadImageColors : Load color data from image as a Color array (RGBA - 32bit)
      # @param image [Image]
      # @return [Color *]
      [:LoadImageColors, :LoadImageColors, [Image.by_value], :pointer],

      # LoadImagePalette : Load colors palette from image as a Color array (RGBA - 32bit)
      # @param image [Image]
      # @param maxPaletteSize [int]
      # @param colorCount [int *]
      # @return [Color *]
      [:LoadImagePalette, :LoadImagePalette, [Image.by_value, :int, :pointer], :pointer],

      # UnloadImageColors : Unload color data loaded with LoadImageColors()
      # @param colors [Color *]
      # @return [void]
      [:UnloadImageColors, :UnloadImageColors, [:pointer], :void],

      # UnloadImagePalette : Unload colors palette loaded with LoadImagePalette()
      # @param colors [Color *]
      # @return [void]
      [:UnloadImagePalette, :UnloadImagePalette, [:pointer], :void],

      # GetImageAlphaBorder : Get image alpha border rectangle
      # @param image [Image]
      # @param threshold [float]
      # @return [Rectangle]
      [:GetImageAlphaBorder, :GetImageAlphaBorder, [Image.by_value, :float], Rectangle.by_value],

      # GetImageColor : Get image pixel color at (x, y) position
      # @param image [Image]
      # @param x [int]
      # @param y [int]
      # @return [Color]
      [:GetImageColor, :GetImageColor, [Image.by_value, :int, :int], Color.by_value],

      # ImageClearBackground : Clear image background with given color
      # @param dst [Image *]
      # @param color [Color]
      # @return [void]
      [:ImageClearBackground, :ImageClearBackground, [:pointer, Color.by_value], :void],

      # ImageDrawPixel : Draw pixel within an image
      # @param dst [Image *]
      # @param posX [int]
      # @param posY [int]
      # @param color [Color]
      # @return [void]
      [:ImageDrawPixel, :ImageDrawPixel, [:pointer, :int, :int, Color.by_value], :void],

      # ImageDrawPixelV : Draw pixel within an image (Vector version)
      # @param dst [Image *]
      # @param position [Vector2]
      # @param color [Color]
      # @return [void]
      [:ImageDrawPixelV, :ImageDrawPixelV, [:pointer, Vector2.by_value, Color.by_value], :void],

      # ImageDrawLine : Draw line within an image
      # @param dst [Image *]
      # @param startPosX [int]
      # @param startPosY [int]
      # @param endPosX [int]
      # @param endPosY [int]
      # @param color [Color]
      # @return [void]
      [:ImageDrawLine, :ImageDrawLine, [:pointer, :int, :int, :int, :int, Color.by_value], :void],

      # ImageDrawLineV : Draw line within an image (Vector version)
      # @param dst [Image *]
      # @param start [Vector2]
      # @param end [Vector2]
      # @param color [Color]
      # @return [void]
      [:ImageDrawLineV, :ImageDrawLineV, [:pointer, Vector2.by_value, Vector2.by_value, Color.by_value], :void],

      # ImageDrawCircle : Draw a filled circle within an image
      # @param dst [Image *]
      # @param centerX [int]
      # @param centerY [int]
      # @param radius [int]
      # @param color [Color]
      # @return [void]
      [:ImageDrawCircle, :ImageDrawCircle, [:pointer, :int, :int, :int, Color.by_value], :void],

      # ImageDrawCircleV : Draw a filled circle within an image (Vector version)
      # @param dst [Image *]
      # @param center [Vector2]
      # @param radius [int]
      # @param color [Color]
      # @return [void]
      [:ImageDrawCircleV, :ImageDrawCircleV, [:pointer, Vector2.by_value, :int, Color.by_value], :void],

      # ImageDrawCircleLines : Draw circle outline within an image
      # @param dst [Image *]
      # @param centerX [int]
      # @param centerY [int]
      # @param radius [int]
      # @param color [Color]
      # @return [void]
      [:ImageDrawCircleLines, :ImageDrawCircleLines, [:pointer, :int, :int, :int, Color.by_value], :void],

      # ImageDrawCircleLinesV : Draw circle outline within an image (Vector version)
      # @param dst [Image *]
      # @param center [Vector2]
      # @param radius [int]
      # @param color [Color]
      # @return [void]
      [:ImageDrawCircleLinesV, :ImageDrawCircleLinesV, [:pointer, Vector2.by_value, :int, Color.by_value], :void],

      # ImageDrawRectangle : Draw rectangle within an image
      # @param dst [Image *]
      # @param posX [int]
      # @param posY [int]
      # @param width [int]
      # @param height [int]
      # @param color [Color]
      # @return [void]
      [:ImageDrawRectangle, :ImageDrawRectangle, [:pointer, :int, :int, :int, :int, Color.by_value], :void],

      # ImageDrawRectangleV : Draw rectangle within an image (Vector version)
      # @param dst [Image *]
      # @param position [Vector2]
      # @param size [Vector2]
      # @param color [Color]
      # @return [void]
      [:ImageDrawRectangleV, :ImageDrawRectangleV, [:pointer, Vector2.by_value, Vector2.by_value, Color.by_value], :void],

      # ImageDrawRectangleRec : Draw rectangle within an image
      # @param dst [Image *]
      # @param rec [Rectangle]
      # @param color [Color]
      # @return [void]
      [:ImageDrawRectangleRec, :ImageDrawRectangleRec, [:pointer, Rectangle.by_value, Color.by_value], :void],

      # ImageDrawRectangleLines : Draw rectangle lines within an image
      # @param dst [Image *]
      # @param rec [Rectangle]
      # @param thick [int]
      # @param color [Color]
      # @return [void]
      [:ImageDrawRectangleLines, :ImageDrawRectangleLines, [:pointer, Rectangle.by_value, :int, Color.by_value], :void],

      # ImageDraw : Draw a source image within a destination image (tint applied to source)
      # @param dst [Image *]
      # @param src [Image]
      # @param srcRec [Rectangle]
      # @param dstRec [Rectangle]
      # @param tint [Color]
      # @return [void]
      [:ImageDraw, :ImageDraw, [:pointer, Image.by_value, Rectangle.by_value, Rectangle.by_value, Color.by_value], :void],

      # ImageDrawText : Draw text (using default font) within an image (destination)
      # @param dst [Image *]
      # @param text [const char *]
      # @param posX [int]
      # @param posY [int]
      # @param fontSize [int]
      # @param color [Color]
      # @return [void]
      [:ImageDrawText, :ImageDrawText, [:pointer, :pointer, :int, :int, :int, Color.by_value], :void],

      # ImageDrawTextEx : Draw text (custom sprite font) within an image (destination)
      # @param dst [Image *]
      # @param font [Font]
      # @param text [const char *]
      # @param position [Vector2]
      # @param fontSize [float]
      # @param spacing [float]
      # @param tint [Color]
      # @return [void]
      [:ImageDrawTextEx, :ImageDrawTextEx, [:pointer, Font.by_value, :pointer, Vector2.by_value, :float, :float, Color.by_value], :void],

      # LoadTexture : Load texture from file into GPU memory (VRAM)
      # @param fileName [const char *]
      # @return [Texture2D]
      [:LoadTexture, :LoadTexture, [:pointer], Texture2D.by_value],

      # LoadTextureFromImage : Load texture from image data
      # @param image [Image]
      # @return [Texture2D]
      [:LoadTextureFromImage, :LoadTextureFromImage, [Image.by_value], Texture2D.by_value],

      # LoadTextureCubemap : Load cubemap from image, multiple image cubemap layouts supported
      # @param image [Image]
      # @param layout [int]
      # @return [TextureCubemap]
      [:LoadTextureCubemap, :LoadTextureCubemap, [Image.by_value, :int], TextureCubemap.by_value],

      # LoadRenderTexture : Load texture for rendering (framebuffer)
      # @param width [int]
      # @param height [int]
      # @return [RenderTexture2D]
      [:LoadRenderTexture, :LoadRenderTexture, [:int, :int], RenderTexture2D.by_value],

      # UnloadTexture : Unload texture from GPU memory (VRAM)
      # @param texture [Texture2D]
      # @return [void]
      [:UnloadTexture, :UnloadTexture, [Texture2D.by_value], :void],

      # UnloadRenderTexture : Unload render texture from GPU memory (VRAM)
      # @param target [RenderTexture2D]
      # @return [void]
      [:UnloadRenderTexture, :UnloadRenderTexture, [RenderTexture2D.by_value], :void],

      # UpdateTexture : Update GPU texture with new data
      # @param texture [Texture2D]
      # @param pixels [const void *]
      # @return [void]
      [:UpdateTexture, :UpdateTexture, [Texture2D.by_value, :pointer], :void],

      # UpdateTextureRec : Update GPU texture rectangle with new data
      # @param texture [Texture2D]
      # @param rec [Rectangle]
      # @param pixels [const void *]
      # @return [void]
      [:UpdateTextureRec, :UpdateTextureRec, [Texture2D.by_value, Rectangle.by_value, :pointer], :void],

      # GenTextureMipmaps : Generate GPU mipmaps for a texture
      # @param texture [Texture2D *]
      # @return [void]
      [:GenTextureMipmaps, :GenTextureMipmaps, [:pointer], :void],

      # SetTextureFilter : Set texture scaling filter mode
      # @param texture [Texture2D]
      # @param filter [int]
      # @return [void]
      [:SetTextureFilter, :SetTextureFilter, [Texture2D.by_value, :int], :void],

      # SetTextureWrap : Set texture wrapping mode
      # @param texture [Texture2D]
      # @param wrap [int]
      # @return [void]
      [:SetTextureWrap, :SetTextureWrap, [Texture2D.by_value, :int], :void],

      # DrawTexture : Draw a Texture2D
      # @param texture [Texture2D]
      # @param posX [int]
      # @param posY [int]
      # @param tint [Color]
      # @return [void]
      [:DrawTexture, :DrawTexture, [Texture2D.by_value, :int, :int, Color.by_value], :void],

      # DrawTextureV : Draw a Texture2D with position defined as Vector2
      # @param texture [Texture2D]
      # @param position [Vector2]
      # @param tint [Color]
      # @return [void]
      [:DrawTextureV, :DrawTextureV, [Texture2D.by_value, Vector2.by_value, Color.by_value], :void],

      # DrawTextureEx : Draw a Texture2D with extended parameters
      # @param texture [Texture2D]
      # @param position [Vector2]
      # @param rotation [float]
      # @param scale [float]
      # @param tint [Color]
      # @return [void]
      [:DrawTextureEx, :DrawTextureEx, [Texture2D.by_value, Vector2.by_value, :float, :float, Color.by_value], :void],

      # DrawTextureRec : Draw a part of a texture defined by a rectangle
      # @param texture [Texture2D]
      # @param source [Rectangle]
      # @param position [Vector2]
      # @param tint [Color]
      # @return [void]
      [:DrawTextureRec, :DrawTextureRec, [Texture2D.by_value, Rectangle.by_value, Vector2.by_value, Color.by_value], :void],

      # DrawTexturePro : Draw a part of a texture defined by a rectangle with 'pro' parameters
      # @param texture [Texture2D]
      # @param source [Rectangle]
      # @param dest [Rectangle]
      # @param origin [Vector2]
      # @param rotation [float]
      # @param tint [Color]
      # @return [void]
      [:DrawTexturePro, :DrawTexturePro, [Texture2D.by_value, Rectangle.by_value, Rectangle.by_value, Vector2.by_value, :float, Color.by_value], :void],

      # DrawTextureNPatch : Draws a texture (or part of it) that stretches or shrinks nicely
      # @param texture [Texture2D]
      # @param nPatchInfo [NPatchInfo]
      # @param dest [Rectangle]
      # @param origin [Vector2]
      # @param rotation [float]
      # @param tint [Color]
      # @return [void]
      [:DrawTextureNPatch, :DrawTextureNPatch, [Texture2D.by_value, NPatchInfo.by_value, Rectangle.by_value, Vector2.by_value, :float, Color.by_value], :void],

      # Fade : Get color with alpha applied, alpha goes from 0.0f to 1.0f
      # @param color [Color]
      # @param alpha [float]
      # @return [Color]
      [:Fade, :Fade, [Color.by_value, :float], Color.by_value],

      # ColorToInt : Get hexadecimal value for a Color
      # @param color [Color]
      # @return [int]
      [:ColorToInt, :ColorToInt, [Color.by_value], :int],

      # ColorNormalize : Get Color normalized as float [0..1]
      # @param color [Color]
      # @return [Vector4]
      [:ColorNormalize, :ColorNormalize, [Color.by_value], Vector4.by_value],

      # ColorFromNormalized : Get Color from normalized values [0..1]
      # @param normalized [Vector4]
      # @return [Color]
      [:ColorFromNormalized, :ColorFromNormalized, [Vector4.by_value], Color.by_value],

      # ColorToHSV : Get HSV values for a Color, hue [0..360], saturation/value [0..1]
      # @param color [Color]
      # @return [Vector3]
      [:ColorToHSV, :ColorToHSV, [Color.by_value], Vector3.by_value],

      # ColorFromHSV : Get a Color from HSV values, hue [0..360], saturation/value [0..1]
      # @param hue [float]
      # @param saturation [float]
      # @param value [float]
      # @return [Color]
      [:ColorFromHSV, :ColorFromHSV, [:float, :float, :float], Color.by_value],

      # ColorTint : Get color multiplied with another color
      # @param color [Color]
      # @param tint [Color]
      # @return [Color]
      [:ColorTint, :ColorTint, [Color.by_value, Color.by_value], Color.by_value],

      # ColorBrightness : Get color with brightness correction, brightness factor goes from -1.0f to 1.0f
      # @param color [Color]
      # @param factor [float]
      # @return [Color]
      [:ColorBrightness, :ColorBrightness, [Color.by_value, :float], Color.by_value],

      # ColorContrast : Get color with contrast correction, contrast values between -1.0f and 1.0f
      # @param color [Color]
      # @param contrast [float]
      # @return [Color]
      [:ColorContrast, :ColorContrast, [Color.by_value, :float], Color.by_value],

      # ColorAlpha : Get color with alpha applied, alpha goes from 0.0f to 1.0f
      # @param color [Color]
      # @param alpha [float]
      # @return [Color]
      [:ColorAlpha, :ColorAlpha, [Color.by_value, :float], Color.by_value],

      # ColorAlphaBlend : Get src alpha-blended into dst color with tint
      # @param dst [Color]
      # @param src [Color]
      # @param tint [Color]
      # @return [Color]
      [:ColorAlphaBlend, :ColorAlphaBlend, [Color.by_value, Color.by_value, Color.by_value], Color.by_value],

      # GetColor : Get Color structure from hexadecimal value
      # @param hexValue [unsigned int]
      # @return [Color]
      [:GetColor, :GetColor, [:uint], Color.by_value],

      # GetPixelColor : Get Color from a source pixel pointer of certain format
      # @param srcPtr [void *]
      # @param format [int]
      # @return [Color]
      [:GetPixelColor, :GetPixelColor, [:pointer, :int], Color.by_value],

      # SetPixelColor : Set color formatted into destination pixel pointer
      # @param dstPtr [void *]
      # @param color [Color]
      # @param format [int]
      # @return [void]
      [:SetPixelColor, :SetPixelColor, [:pointer, Color.by_value, :int], :void],

      # GetPixelDataSize : Get pixel data size in bytes for certain format
      # @param width [int]
      # @param height [int]
      # @param format [int]
      # @return [int]
      [:GetPixelDataSize, :GetPixelDataSize, [:int, :int, :int], :int],

      # GetFontDefault : Get the default Font
      # @return [Font]
      [:GetFontDefault, :GetFontDefault, [], Font.by_value],

      # LoadFont : Load font from file into GPU memory (VRAM)
      # @param fileName [const char *]
      # @return [Font]
      [:LoadFont, :LoadFont, [:pointer], Font.by_value],

      # LoadFontEx : Load font from file with extended parameters, use NULL for fontChars and 0 for glyphCount to load the default character set
      # @param fileName [const char *]
      # @param fontSize [int]
      # @param fontChars [int *]
      # @param glyphCount [int]
      # @return [Font]
      [:LoadFontEx, :LoadFontEx, [:pointer, :int, :pointer, :int], Font.by_value],

      # LoadFontFromImage : Load font from Image (XNA style)
      # @param image [Image]
      # @param key [Color]
      # @param firstChar [int]
      # @return [Font]
      [:LoadFontFromImage, :LoadFontFromImage, [Image.by_value, Color.by_value, :int], Font.by_value],

      # LoadFontFromMemory : Load font from memory buffer, fileType refers to extension: i.e. '.ttf'
      # @param fileType [const char *]
      # @param fileData [const unsigned char *]
      # @param dataSize [int]
      # @param fontSize [int]
      # @param fontChars [int *]
      # @param glyphCount [int]
      # @return [Font]
      [:LoadFontFromMemory, :LoadFontFromMemory, [:pointer, :pointer, :int, :int, :pointer, :int], Font.by_value],

      # LoadFontData : Load font data for further use
      # @param fileData [const unsigned char *]
      # @param dataSize [int]
      # @param fontSize [int]
      # @param fontChars [int *]
      # @param glyphCount [int]
      # @param type [int]
      # @return [GlyphInfo *]
      [:LoadFontData, :LoadFontData, [:pointer, :int, :int, :pointer, :int, :int], :pointer],

      # GenImageFontAtlas : Generate image font atlas using chars info
      # @param chars [const GlyphInfo *]
      # @param recs [Rectangle **]
      # @param glyphCount [int]
      # @param fontSize [int]
      # @param padding [int]
      # @param packMethod [int]
      # @return [Image]
      [:GenImageFontAtlas, :GenImageFontAtlas, [:pointer, :pointer, :int, :int, :int, :int], Image.by_value],

      # UnloadFontData : Unload font chars info data (RAM)
      # @param chars [GlyphInfo *]
      # @param glyphCount [int]
      # @return [void]
      [:UnloadFontData, :UnloadFontData, [:pointer, :int], :void],

      # UnloadFont : Unload font from GPU memory (VRAM)
      # @param font [Font]
      # @return [void]
      [:UnloadFont, :UnloadFont, [Font.by_value], :void],

      # ExportFontAsCode : Export font as code file, returns true on success
      # @param font [Font]
      # @param fileName [const char *]
      # @return [bool]
      [:ExportFontAsCode, :ExportFontAsCode, [Font.by_value, :pointer], :bool],

      # DrawFPS : Draw current FPS
      # @param posX [int]
      # @param posY [int]
      # @return [void]
      [:DrawFPS, :DrawFPS, [:int, :int], :void],

      # DrawText : Draw text (using default font)
      # @param text [const char *]
      # @param posX [int]
      # @param posY [int]
      # @param fontSize [int]
      # @param color [Color]
      # @return [void]
      [:DrawText, :DrawText, [:pointer, :int, :int, :int, Color.by_value], :void],

      # DrawTextEx : Draw text using font and additional parameters
      # @param font [Font]
      # @param text [const char *]
      # @param position [Vector2]
      # @param fontSize [float]
      # @param spacing [float]
      # @param tint [Color]
      # @return [void]
      [:DrawTextEx, :DrawTextEx, [Font.by_value, :pointer, Vector2.by_value, :float, :float, Color.by_value], :void],

      # DrawTextPro : Draw text using Font and pro parameters (rotation)
      # @param font [Font]
      # @param text [const char *]
      # @param position [Vector2]
      # @param origin [Vector2]
      # @param rotation [float]
      # @param fontSize [float]
      # @param spacing [float]
      # @param tint [Color]
      # @return [void]
      [:DrawTextPro, :DrawTextPro, [Font.by_value, :pointer, Vector2.by_value, Vector2.by_value, :float, :float, :float, Color.by_value], :void],

      # DrawTextCodepoint : Draw one character (codepoint)
      # @param font [Font]
      # @param codepoint [int]
      # @param position [Vector2]
      # @param fontSize [float]
      # @param tint [Color]
      # @return [void]
      [:DrawTextCodepoint, :DrawTextCodepoint, [Font.by_value, :int, Vector2.by_value, :float, Color.by_value], :void],

      # DrawTextCodepoints : Draw multiple character (codepoint)
      # @param font [Font]
      # @param codepoints [const int *]
      # @param count [int]
      # @param position [Vector2]
      # @param fontSize [float]
      # @param spacing [float]
      # @param tint [Color]
      # @return [void]
      [:DrawTextCodepoints, :DrawTextCodepoints, [Font.by_value, :pointer, :int, Vector2.by_value, :float, :float, Color.by_value], :void],

      # MeasureText : Measure string width for default font
      # @param text [const char *]
      # @param fontSize [int]
      # @return [int]
      [:MeasureText, :MeasureText, [:pointer, :int], :int],

      # MeasureTextEx : Measure string size for Font
      # @param font [Font]
      # @param text [const char *]
      # @param fontSize [float]
      # @param spacing [float]
      # @return [Vector2]
      [:MeasureTextEx, :MeasureTextEx, [Font.by_value, :pointer, :float, :float], Vector2.by_value],

      # GetGlyphIndex : Get glyph index position in font for a codepoint (unicode character), fallback to '?' if not found
      # @param font [Font]
      # @param codepoint [int]
      # @return [int]
      [:GetGlyphIndex, :GetGlyphIndex, [Font.by_value, :int], :int],

      # GetGlyphInfo : Get glyph font info data for a codepoint (unicode character), fallback to '?' if not found
      # @param font [Font]
      # @param codepoint [int]
      # @return [GlyphInfo]
      [:GetGlyphInfo, :GetGlyphInfo, [Font.by_value, :int], GlyphInfo.by_value],

      # GetGlyphAtlasRec : Get glyph rectangle in font atlas for a codepoint (unicode character), fallback to '?' if not found
      # @param font [Font]
      # @param codepoint [int]
      # @return [Rectangle]
      [:GetGlyphAtlasRec, :GetGlyphAtlasRec, [Font.by_value, :int], Rectangle.by_value],

      # LoadUTF8 : Load UTF-8 text encoded from codepoints array
      # @param codepoints [const int *]
      # @param length [int]
      # @return [char *]
      [:LoadUTF8, :LoadUTF8, [:pointer, :int], :pointer],

      # UnloadUTF8 : Unload UTF-8 text encoded from codepoints array
      # @param text [char *]
      # @return [void]
      [:UnloadUTF8, :UnloadUTF8, [:pointer], :void],

      # LoadCodepoints : Load all codepoints from a UTF-8 text string, codepoints count returned by parameter
      # @param text [const char *]
      # @param count [int *]
      # @return [int *]
      [:LoadCodepoints, :LoadCodepoints, [:pointer, :pointer], :pointer],

      # UnloadCodepoints : Unload codepoints data from memory
      # @param codepoints [int *]
      # @return [void]
      [:UnloadCodepoints, :UnloadCodepoints, [:pointer], :void],

      # GetCodepointCount : Get total number of codepoints in a UTF-8 encoded string
      # @param text [const char *]
      # @return [int]
      [:GetCodepointCount, :GetCodepointCount, [:pointer], :int],

      # GetCodepoint : Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
      # @param text [const char *]
      # @param codepointSize [int *]
      # @return [int]
      [:GetCodepoint, :GetCodepoint, [:pointer, :pointer], :int],

      # GetCodepointNext : Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
      # @param text [const char *]
      # @param codepointSize [int *]
      # @return [int]
      [:GetCodepointNext, :GetCodepointNext, [:pointer, :pointer], :int],

      # GetCodepointPrevious : Get previous codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
      # @param text [const char *]
      # @param codepointSize [int *]
      # @return [int]
      [:GetCodepointPrevious, :GetCodepointPrevious, [:pointer, :pointer], :int],

      # CodepointToUTF8 : Encode one codepoint into UTF-8 byte array (array length returned as parameter)
      # @param codepoint [int]
      # @param utf8Size [int *]
      # @return [const char *]
      [:CodepointToUTF8, :CodepointToUTF8, [:int, :pointer], :pointer],

      # TextCopy : Copy one string to another, returns bytes copied
      # @param dst [char *]
      # @param src [const char *]
      # @return [int]
      [:TextCopy, :TextCopy, [:pointer, :pointer], :int],

      # TextIsEqual : Check if two text string are equal
      # @param text1 [const char *]
      # @param text2 [const char *]
      # @return [bool]
      [:TextIsEqual, :TextIsEqual, [:pointer, :pointer], :bool],

      # TextLength : Get text length, checks for '\0' ending
      # @param text [const char *]
      # @return [unsigned int]
      [:TextLength, :TextLength, [:pointer], :uint],

      # TextFormat : Text formatting with variables (sprintf() style)
      # @param text [const char *]
      # @param args [...]
      # @return [const char *]
      [:TextFormat, :TextFormat, [:pointer, :varargs], :pointer],

      # TextSubtext : Get a piece of a text string
      # @param text [const char *]
      # @param position [int]
      # @param length [int]
      # @return [const char *]
      [:TextSubtext, :TextSubtext, [:pointer, :int, :int], :pointer],

      # TextReplace : Replace text string (WARNING: memory must be freed!)
      # @param text [char *]
      # @param replace [const char *]
      # @param by [const char *]
      # @return [char *]
      [:TextReplace, :TextReplace, [:pointer, :pointer, :pointer], :pointer],

      # TextInsert : Insert text in a position (WARNING: memory must be freed!)
      # @param text [const char *]
      # @param insert [const char *]
      # @param position [int]
      # @return [char *]
      [:TextInsert, :TextInsert, [:pointer, :pointer, :int], :pointer],

      # TextJoin : Join text strings with delimiter
      # @param textList [const char **]
      # @param count [int]
      # @param delimiter [const char *]
      # @return [const char *]
      [:TextJoin, :TextJoin, [:pointer, :int, :pointer], :pointer],

      # TextSplit : Split text into multiple strings
      # @param text [const char *]
      # @param delimiter [char]
      # @param count [int *]
      # @return [const char **]
      [:TextSplit, :TextSplit, [:pointer, :char, :pointer], :pointer],

      # TextAppend : Append text at specific position and move cursor!
      # @param text [char *]
      # @param append [const char *]
      # @param position [int *]
      # @return [void]
      [:TextAppend, :TextAppend, [:pointer, :pointer, :pointer], :void],

      # TextFindIndex : Find first text occurrence within a string
      # @param text [const char *]
      # @param find [const char *]
      # @return [int]
      [:TextFindIndex, :TextFindIndex, [:pointer, :pointer], :int],

      # TextToUpper : Get upper case version of provided string
      # @param text [const char *]
      # @return [const char *]
      [:TextToUpper, :TextToUpper, [:pointer], :pointer],

      # TextToLower : Get lower case version of provided string
      # @param text [const char *]
      # @return [const char *]
      [:TextToLower, :TextToLower, [:pointer], :pointer],

      # TextToPascal : Get Pascal case notation version of provided string
      # @param text [const char *]
      # @return [const char *]
      [:TextToPascal, :TextToPascal, [:pointer], :pointer],

      # TextToInteger : Get integer value from text (negative values not supported)
      # @param text [const char *]
      # @return [int]
      [:TextToInteger, :TextToInteger, [:pointer], :int],

      # DrawLine3D : Draw a line in 3D world space
      # @param startPos [Vector3]
      # @param endPos [Vector3]
      # @param color [Color]
      # @return [void]
      [:DrawLine3D, :DrawLine3D, [Vector3.by_value, Vector3.by_value, Color.by_value], :void],

      # DrawPoint3D : Draw a point in 3D space, actually a small line
      # @param position [Vector3]
      # @param color [Color]
      # @return [void]
      [:DrawPoint3D, :DrawPoint3D, [Vector3.by_value, Color.by_value], :void],

      # DrawCircle3D : Draw a circle in 3D world space
      # @param center [Vector3]
      # @param radius [float]
      # @param rotationAxis [Vector3]
      # @param rotationAngle [float]
      # @param color [Color]
      # @return [void]
      [:DrawCircle3D, :DrawCircle3D, [Vector3.by_value, :float, Vector3.by_value, :float, Color.by_value], :void],

      # DrawTriangle3D : Draw a color-filled triangle (vertex in counter-clockwise order!)
      # @param v1 [Vector3]
      # @param v2 [Vector3]
      # @param v3 [Vector3]
      # @param color [Color]
      # @return [void]
      [:DrawTriangle3D, :DrawTriangle3D, [Vector3.by_value, Vector3.by_value, Vector3.by_value, Color.by_value], :void],

      # DrawTriangleStrip3D : Draw a triangle strip defined by points
      # @param points [Vector3 *]
      # @param pointCount [int]
      # @param color [Color]
      # @return [void]
      [:DrawTriangleStrip3D, :DrawTriangleStrip3D, [:pointer, :int, Color.by_value], :void],

      # DrawCube : Draw cube
      # @param position [Vector3]
      # @param width [float]
      # @param height [float]
      # @param length [float]
      # @param color [Color]
      # @return [void]
      [:DrawCube, :DrawCube, [Vector3.by_value, :float, :float, :float, Color.by_value], :void],

      # DrawCubeV : Draw cube (Vector version)
      # @param position [Vector3]
      # @param size [Vector3]
      # @param color [Color]
      # @return [void]
      [:DrawCubeV, :DrawCubeV, [Vector3.by_value, Vector3.by_value, Color.by_value], :void],

      # DrawCubeWires : Draw cube wires
      # @param position [Vector3]
      # @param width [float]
      # @param height [float]
      # @param length [float]
      # @param color [Color]
      # @return [void]
      [:DrawCubeWires, :DrawCubeWires, [Vector3.by_value, :float, :float, :float, Color.by_value], :void],

      # DrawCubeWiresV : Draw cube wires (Vector version)
      # @param position [Vector3]
      # @param size [Vector3]
      # @param color [Color]
      # @return [void]
      [:DrawCubeWiresV, :DrawCubeWiresV, [Vector3.by_value, Vector3.by_value, Color.by_value], :void],

      # DrawSphere : Draw sphere
      # @param centerPos [Vector3]
      # @param radius [float]
      # @param color [Color]
      # @return [void]
      [:DrawSphere, :DrawSphere, [Vector3.by_value, :float, Color.by_value], :void],

      # DrawSphereEx : Draw sphere with extended parameters
      # @param centerPos [Vector3]
      # @param radius [float]
      # @param rings [int]
      # @param slices [int]
      # @param color [Color]
      # @return [void]
      [:DrawSphereEx, :DrawSphereEx, [Vector3.by_value, :float, :int, :int, Color.by_value], :void],

      # DrawSphereWires : Draw sphere wires
      # @param centerPos [Vector3]
      # @param radius [float]
      # @param rings [int]
      # @param slices [int]
      # @param color [Color]
      # @return [void]
      [:DrawSphereWires, :DrawSphereWires, [Vector3.by_value, :float, :int, :int, Color.by_value], :void],

      # DrawCylinder : Draw a cylinder/cone
      # @param position [Vector3]
      # @param radiusTop [float]
      # @param radiusBottom [float]
      # @param height [float]
      # @param slices [int]
      # @param color [Color]
      # @return [void]
      [:DrawCylinder, :DrawCylinder, [Vector3.by_value, :float, :float, :float, :int, Color.by_value], :void],

      # DrawCylinderEx : Draw a cylinder with base at startPos and top at endPos
      # @param startPos [Vector3]
      # @param endPos [Vector3]
      # @param startRadius [float]
      # @param endRadius [float]
      # @param sides [int]
      # @param color [Color]
      # @return [void]
      [:DrawCylinderEx, :DrawCylinderEx, [Vector3.by_value, Vector3.by_value, :float, :float, :int, Color.by_value], :void],

      # DrawCylinderWires : Draw a cylinder/cone wires
      # @param position [Vector3]
      # @param radiusTop [float]
      # @param radiusBottom [float]
      # @param height [float]
      # @param slices [int]
      # @param color [Color]
      # @return [void]
      [:DrawCylinderWires, :DrawCylinderWires, [Vector3.by_value, :float, :float, :float, :int, Color.by_value], :void],

      # DrawCylinderWiresEx : Draw a cylinder wires with base at startPos and top at endPos
      # @param startPos [Vector3]
      # @param endPos [Vector3]
      # @param startRadius [float]
      # @param endRadius [float]
      # @param sides [int]
      # @param color [Color]
      # @return [void]
      [:DrawCylinderWiresEx, :DrawCylinderWiresEx, [Vector3.by_value, Vector3.by_value, :float, :float, :int, Color.by_value], :void],

      # DrawCapsule : Draw a capsule with the center of its sphere caps at startPos and endPos
      # @param startPos [Vector3]
      # @param endPos [Vector3]
      # @param radius [float]
      # @param slices [int]
      # @param rings [int]
      # @param color [Color]
      # @return [void]
      [:DrawCapsule, :DrawCapsule, [Vector3.by_value, Vector3.by_value, :float, :int, :int, Color.by_value], :void],

      # DrawCapsuleWires : Draw capsule wireframe with the center of its sphere caps at startPos and endPos
      # @param startPos [Vector3]
      # @param endPos [Vector3]
      # @param radius [float]
      # @param slices [int]
      # @param rings [int]
      # @param color [Color]
      # @return [void]
      [:DrawCapsuleWires, :DrawCapsuleWires, [Vector3.by_value, Vector3.by_value, :float, :int, :int, Color.by_value], :void],

      # DrawPlane : Draw a plane XZ
      # @param centerPos [Vector3]
      # @param size [Vector2]
      # @param color [Color]
      # @return [void]
      [:DrawPlane, :DrawPlane, [Vector3.by_value, Vector2.by_value, Color.by_value], :void],

      # DrawRay : Draw a ray line
      # @param ray [Ray]
      # @param color [Color]
      # @return [void]
      [:DrawRay, :DrawRay, [Ray.by_value, Color.by_value], :void],

      # DrawGrid : Draw a grid (centered at (0, 0, 0))
      # @param slices [int]
      # @param spacing [float]
      # @return [void]
      [:DrawGrid, :DrawGrid, [:int, :float], :void],

      # LoadModel : Load model from files (meshes and materials)
      # @param fileName [const char *]
      # @return [Model]
      [:LoadModel, :LoadModel, [:pointer], Model.by_value],

      # LoadModelFromMesh : Load model from generated mesh (default material)
      # @param mesh [Mesh]
      # @return [Model]
      [:LoadModelFromMesh, :LoadModelFromMesh, [Mesh.by_value], Model.by_value],

      # UnloadModel : Unload model (including meshes) from memory (RAM and/or VRAM)
      # @param model [Model]
      # @return [void]
      [:UnloadModel, :UnloadModel, [Model.by_value], :void],

      # UnloadModelKeepMeshes : Unload model (but not meshes) from memory (RAM and/or VRAM)
      # @param model [Model]
      # @return [void]
      [:UnloadModelKeepMeshes, :UnloadModelKeepMeshes, [Model.by_value], :void],

      # GetModelBoundingBox : Compute model bounding box limits (considers all meshes)
      # @param model [Model]
      # @return [BoundingBox]
      [:GetModelBoundingBox, :GetModelBoundingBox, [Model.by_value], BoundingBox.by_value],

      # DrawModel : Draw a model (with texture if set)
      # @param model [Model]
      # @param position [Vector3]
      # @param scale [float]
      # @param tint [Color]
      # @return [void]
      [:DrawModel, :DrawModel, [Model.by_value, Vector3.by_value, :float, Color.by_value], :void],

      # internalDrawModelEx : Draw a model with extended parameters
      # @param model [Model]
      # @param position [Vector3]
      # @param rotationAxis [Vector3]
      # @param rotationAngle [float]
      # @param scale [Vector3]
      # @param tint [Color]
      # @return [void]
      [:internalDrawModelEx, :DrawModelEx, [Model.by_value, Vector3.by_value, Vector3.by_value, :float, Vector3.by_value, Color.by_value], :void],

      # DrawModelWires : Draw a model wires (with texture if set)
      # @param model [Model]
      # @param position [Vector3]
      # @param scale [float]
      # @param tint [Color]
      # @return [void]
      [:DrawModelWires, :DrawModelWires, [Model.by_value, Vector3.by_value, :float, Color.by_value], :void],

      # DrawModelWiresEx : Draw a model wires (with texture if set) with extended parameters
      # @param model [Model]
      # @param position [Vector3]
      # @param rotationAxis [Vector3]
      # @param rotationAngle [float]
      # @param scale [Vector3]
      # @param tint [Color]
      # @return [void]
      [:DrawModelWiresEx, :DrawModelWiresEx, [Model.by_value, Vector3.by_value, Vector3.by_value, :float, Vector3.by_value, Color.by_value], :void],

      # DrawBoundingBox : Draw bounding box (wires)
      # @param box [BoundingBox]
      # @param color [Color]
      # @return [void]
      [:DrawBoundingBox, :DrawBoundingBox, [BoundingBox.by_value, Color.by_value], :void],

      # DrawBillboard : Draw a billboard texture
      # @param camera [Camera]
      # @param texture [Texture2D]
      # @param position [Vector3]
      # @param size [float]
      # @param tint [Color]
      # @return [void]
      [:DrawBillboard, :DrawBillboard, [Camera.by_value, Texture2D.by_value, Vector3.by_value, :float, Color.by_value], :void],

      # DrawBillboardRec : Draw a billboard texture defined by source
      # @param camera [Camera]
      # @param texture [Texture2D]
      # @param source [Rectangle]
      # @param position [Vector3]
      # @param size [Vector2]
      # @param tint [Color]
      # @return [void]
      [:DrawBillboardRec, :DrawBillboardRec, [Camera.by_value, Texture2D.by_value, Rectangle.by_value, Vector3.by_value, Vector2.by_value, Color.by_value], :void],

      # DrawBillboardPro : Draw a billboard texture defined by source and rotation
      # @param camera [Camera]
      # @param texture [Texture2D]
      # @param source [Rectangle]
      # @param position [Vector3]
      # @param up [Vector3]
      # @param size [Vector2]
      # @param origin [Vector2]
      # @param rotation [float]
      # @param tint [Color]
      # @return [void]
      [:DrawBillboardPro, :DrawBillboardPro, [Camera.by_value, Texture2D.by_value, Rectangle.by_value, Vector3.by_value, Vector3.by_value, Vector2.by_value, Vector2.by_value, :float, Color.by_value], :void],

      # UploadMesh : Upload mesh vertex data in GPU and provide VAO/VBO ids
      # @param mesh [Mesh *]
      # @param dynamic [bool]
      # @return [void]
      [:UploadMesh, :UploadMesh, [:pointer, :bool], :void],

      # UpdateMeshBuffer : Update mesh vertex data in GPU for a specific buffer index
      # @param mesh [Mesh]
      # @param index [int]
      # @param data [const void *]
      # @param dataSize [int]
      # @param offset [int]
      # @return [void]
      [:UpdateMeshBuffer, :UpdateMeshBuffer, [Mesh.by_value, :int, :pointer, :int, :int], :void],

      # UnloadMesh : Unload mesh data from CPU and GPU
      # @param mesh [Mesh]
      # @return [void]
      [:UnloadMesh, :UnloadMesh, [Mesh.by_value], :void],

      # DrawMesh : Draw a 3d mesh with material and transform
      # @param mesh [Mesh]
      # @param material [Material]
      # @param transform [Matrix]
      # @return [void]
      [:DrawMesh, :DrawMesh, [Mesh.by_value, Material.by_value, Matrix.by_value], :void],

      # DrawMeshInstanced : Draw multiple mesh instances with material and different transforms
      # @param mesh [Mesh]
      # @param material [Material]
      # @param transforms [const Matrix *]
      # @param instances [int]
      # @return [void]
      [:DrawMeshInstanced, :DrawMeshInstanced, [Mesh.by_value, Material.by_value, :pointer, :int], :void],

      # ExportMesh : Export mesh data to file, returns true on success
      # @param mesh [Mesh]
      # @param fileName [const char *]
      # @return [bool]
      [:ExportMesh, :ExportMesh, [Mesh.by_value, :pointer], :bool],

      # GetMeshBoundingBox : Compute mesh bounding box limits
      # @param mesh [Mesh]
      # @return [BoundingBox]
      [:GetMeshBoundingBox, :GetMeshBoundingBox, [Mesh.by_value], BoundingBox.by_value],

      # GenMeshTangents : Compute mesh tangents
      # @param mesh [Mesh *]
      # @return [void]
      [:GenMeshTangents, :GenMeshTangents, [:pointer], :void],

      # GenMeshPoly : Generate polygonal mesh
      # @param sides [int]
      # @param radius [float]
      # @return [Mesh]
      [:GenMeshPoly, :GenMeshPoly, [:int, :float], Mesh.by_value],

      # GenMeshPlane : Generate plane mesh (with subdivisions)
      # @param width [float]
      # @param length [float]
      # @param resX [int]
      # @param resZ [int]
      # @return [Mesh]
      [:GenMeshPlane, :GenMeshPlane, [:float, :float, :int, :int], Mesh.by_value],

      # GenMeshCube : Generate cuboid mesh
      # @param width [float]
      # @param height [float]
      # @param length [float]
      # @return [Mesh]
      [:GenMeshCube, :GenMeshCube, [:float, :float, :float], Mesh.by_value],

      # GenMeshSphere : Generate sphere mesh (standard sphere)
      # @param radius [float]
      # @param rings [int]
      # @param slices [int]
      # @return [Mesh]
      [:GenMeshSphere, :GenMeshSphere, [:float, :int, :int], Mesh.by_value],

      # GenMeshHemiSphere : Generate half-sphere mesh (no bottom cap)
      # @param radius [float]
      # @param rings [int]
      # @param slices [int]
      # @return [Mesh]
      [:GenMeshHemiSphere, :GenMeshHemiSphere, [:float, :int, :int], Mesh.by_value],

      # GenMeshCylinder : Generate cylinder mesh
      # @param radius [float]
      # @param height [float]
      # @param slices [int]
      # @return [Mesh]
      [:GenMeshCylinder, :GenMeshCylinder, [:float, :float, :int], Mesh.by_value],

      # GenMeshCone : Generate cone/pyramid mesh
      # @param radius [float]
      # @param height [float]
      # @param slices [int]
      # @return [Mesh]
      [:GenMeshCone, :GenMeshCone, [:float, :float, :int], Mesh.by_value],

      # GenMeshTorus : Generate torus mesh
      # @param radius [float]
      # @param size [float]
      # @param radSeg [int]
      # @param sides [int]
      # @return [Mesh]
      [:GenMeshTorus, :GenMeshTorus, [:float, :float, :int, :int], Mesh.by_value],

      # GenMeshKnot : Generate trefoil knot mesh
      # @param radius [float]
      # @param size [float]
      # @param radSeg [int]
      # @param sides [int]
      # @return [Mesh]
      [:GenMeshKnot, :GenMeshKnot, [:float, :float, :int, :int], Mesh.by_value],

      # GenMeshHeightmap : Generate heightmap mesh from image data
      # @param heightmap [Image]
      # @param size [Vector3]
      # @return [Mesh]
      [:GenMeshHeightmap, :GenMeshHeightmap, [Image.by_value, Vector3.by_value], Mesh.by_value],

      # GenMeshCubicmap : Generate cubes-based map mesh from image data
      # @param cubicmap [Image]
      # @param cubeSize [Vector3]
      # @return [Mesh]
      [:GenMeshCubicmap, :GenMeshCubicmap, [Image.by_value, Vector3.by_value], Mesh.by_value],

      # LoadMaterials : Load materials from model file
      # @param fileName [const char *]
      # @param materialCount [int *]
      # @return [Material *]
      [:LoadMaterials, :LoadMaterials, [:pointer, :pointer], :pointer],

      # LoadMaterialDefault : Load default material (Supports: DIFFUSE, SPECULAR, NORMAL maps)
      # @return [Material]
      [:LoadMaterialDefault, :LoadMaterialDefault, [], Material.by_value],

      # UnloadMaterial : Unload material from GPU memory (VRAM)
      # @param material [Material]
      # @return [void]
      [:UnloadMaterial, :UnloadMaterial, [Material.by_value], :void],

      # SetMaterialTexture : Set texture for a material map type (MATERIAL_MAP_DIFFUSE, MATERIAL_MAP_SPECULAR...)
      # @param material [Material *]
      # @param mapType [int]
      # @param texture [Texture2D]
      # @return [void]
      [:SetMaterialTexture, :SetMaterialTexture, [:pointer, :int, Texture2D.by_value], :void],

      # SetModelMeshMaterial : Set material for a mesh
      # @param model [Model *]
      # @param meshId [int]
      # @param materialId [int]
      # @return [void]
      [:SetModelMeshMaterial, :SetModelMeshMaterial, [:pointer, :int, :int], :void],

      # LoadModelAnimations : Load model animations from file
      # @param fileName [const char *]
      # @param animCount [unsigned int *]
      # @return [ModelAnimation *]
      [:LoadModelAnimations, :LoadModelAnimations, [:pointer, :pointer], :pointer],

      # UpdateModelAnimation : Update model animation pose
      # @param model [Model]
      # @param anim [ModelAnimation]
      # @param frame [int]
      # @return [void]
      [:UpdateModelAnimation, :UpdateModelAnimation, [Model.by_value, ModelAnimation.by_value, :int], :void],

      # UnloadModelAnimation : Unload animation data
      # @param anim [ModelAnimation]
      # @return [void]
      [:UnloadModelAnimation, :UnloadModelAnimation, [ModelAnimation.by_value], :void],

      # UnloadModelAnimations : Unload animation array data
      # @param animations [ModelAnimation *]
      # @param count [unsigned int]
      # @return [void]
      [:UnloadModelAnimations, :UnloadModelAnimations, [:pointer, :uint], :void],

      # IsModelAnimationValid : Check model animation skeleton match
      # @param model [Model]
      # @param anim [ModelAnimation]
      # @return [bool]
      [:IsModelAnimationValid, :IsModelAnimationValid, [Model.by_value, ModelAnimation.by_value], :bool],

      # CheckCollisionSpheres : Check collision between two spheres
      # @param center1 [Vector3]
      # @param radius1 [float]
      # @param center2 [Vector3]
      # @param radius2 [float]
      # @return [bool]
      [:CheckCollisionSpheres, :CheckCollisionSpheres, [Vector3.by_value, :float, Vector3.by_value, :float], :bool],

      # CheckCollisionBoxes : Check collision between two bounding boxes
      # @param box1 [BoundingBox]
      # @param box2 [BoundingBox]
      # @return [bool]
      [:CheckCollisionBoxes, :CheckCollisionBoxes, [BoundingBox.by_value, BoundingBox.by_value], :bool],

      # CheckCollisionBoxSphere : Check collision between box and sphere
      # @param box [BoundingBox]
      # @param center [Vector3]
      # @param radius [float]
      # @return [bool]
      [:CheckCollisionBoxSphere, :CheckCollisionBoxSphere, [BoundingBox.by_value, Vector3.by_value, :float], :bool],

      # GetRayCollisionSphere : Get collision info between ray and sphere
      # @param ray [Ray]
      # @param center [Vector3]
      # @param radius [float]
      # @return [RayCollision]
      [:GetRayCollisionSphere, :GetRayCollisionSphere, [Ray.by_value, Vector3.by_value, :float], RayCollision.by_value],

      # GetRayCollisionBox : Get collision info between ray and box
      # @param ray [Ray]
      # @param box [BoundingBox]
      # @return [RayCollision]
      [:GetRayCollisionBox, :GetRayCollisionBox, [Ray.by_value, BoundingBox.by_value], RayCollision.by_value],

      # GetRayCollisionMesh : Get collision info between ray and mesh
      # @param ray [Ray]
      # @param mesh [Mesh]
      # @param transform [Matrix]
      # @return [RayCollision]
      [:GetRayCollisionMesh, :GetRayCollisionMesh, [Ray.by_value, Mesh.by_value, Matrix.by_value], RayCollision.by_value],

      # GetRayCollisionTriangle : Get collision info between ray and triangle
      # @param ray [Ray]
      # @param p1 [Vector3]
      # @param p2 [Vector3]
      # @param p3 [Vector3]
      # @return [RayCollision]
      [:GetRayCollisionTriangle, :GetRayCollisionTriangle, [Ray.by_value, Vector3.by_value, Vector3.by_value, Vector3.by_value], RayCollision.by_value],

      # GetRayCollisionQuad : Get collision info between ray and quad
      # @param ray [Ray]
      # @param p1 [Vector3]
      # @param p2 [Vector3]
      # @param p3 [Vector3]
      # @param p4 [Vector3]
      # @return [RayCollision]
      [:GetRayCollisionQuad, :GetRayCollisionQuad, [Ray.by_value, Vector3.by_value, Vector3.by_value, Vector3.by_value, Vector3.by_value], RayCollision.by_value],

      # InitAudioDevice : Initialize audio device and context
      # @return [void]
      [:InitAudioDevice, :InitAudioDevice, [], :void],

      # CloseAudioDevice : Close the audio device and context
      # @return [void]
      [:CloseAudioDevice, :CloseAudioDevice, [], :void],

      # IsAudioDeviceReady : Check if audio device has been initialized successfully
      # @return [bool]
      [:IsAudioDeviceReady, :IsAudioDeviceReady, [], :bool],

      # SetMasterVolume : Set master volume (listener)
      # @param volume [float]
      # @return [void]
      [:SetMasterVolume, :SetMasterVolume, [:float], :void],

      # LoadWave : Load wave data from file
      # @param fileName [const char *]
      # @return [Wave]
      [:LoadWave, :LoadWave, [:pointer], Wave.by_value],

      # LoadWaveFromMemory : Load wave from memory buffer, fileType refers to extension: i.e. '.wav'
      # @param fileType [const char *]
      # @param fileData [const unsigned char *]
      # @param dataSize [int]
      # @return [Wave]
      [:LoadWaveFromMemory, :LoadWaveFromMemory, [:pointer, :pointer, :int], Wave.by_value],

      # LoadSound : Load sound from file
      # @param fileName [const char *]
      # @return [Sound]
      [:LoadSound, :LoadSound, [:pointer], Sound.by_value],

      # LoadSoundFromWave : Load sound from wave data
      # @param wave [Wave]
      # @return [Sound]
      [:LoadSoundFromWave, :LoadSoundFromWave, [Wave.by_value], Sound.by_value],

      # UpdateSound : Update sound buffer with new data
      # @param sound [Sound]
      # @param data [const void *]
      # @param sampleCount [int]
      # @return [void]
      [:UpdateSound, :UpdateSound, [Sound.by_value, :pointer, :int], :void],

      # UnloadWave : Unload wave data
      # @param wave [Wave]
      # @return [void]
      [:UnloadWave, :UnloadWave, [Wave.by_value], :void],

      # UnloadSound : Unload sound
      # @param sound [Sound]
      # @return [void]
      [:UnloadSound, :UnloadSound, [Sound.by_value], :void],

      # ExportWave : Export wave data to file, returns true on success
      # @param wave [Wave]
      # @param fileName [const char *]
      # @return [bool]
      [:ExportWave, :ExportWave, [Wave.by_value, :pointer], :bool],

      # ExportWaveAsCode : Export wave sample data to code (.h), returns true on success
      # @param wave [Wave]
      # @param fileName [const char *]
      # @return [bool]
      [:ExportWaveAsCode, :ExportWaveAsCode, [Wave.by_value, :pointer], :bool],

      # PlaySound : Play a sound
      # @param sound [Sound]
      # @return [void]
      [:PlaySound, :PlaySound, [Sound.by_value], :void],

      # StopSound : Stop playing a sound
      # @param sound [Sound]
      # @return [void]
      [:StopSound, :StopSound, [Sound.by_value], :void],

      # PauseSound : Pause a sound
      # @param sound [Sound]
      # @return [void]
      [:PauseSound, :PauseSound, [Sound.by_value], :void],

      # ResumeSound : Resume a paused sound
      # @param sound [Sound]
      # @return [void]
      [:ResumeSound, :ResumeSound, [Sound.by_value], :void],

      # PlaySoundMulti : Play a sound (using multichannel buffer pool)
      # @param sound [Sound]
      # @return [void]
      [:PlaySoundMulti, :PlaySoundMulti, [Sound.by_value], :void],

      # StopSoundMulti : Stop any sound playing (using multichannel buffer pool)
      # @return [void]
      [:StopSoundMulti, :StopSoundMulti, [], :void],

      # GetSoundsPlaying : Get number of sounds playing in the multichannel
      # @return [int]
      [:GetSoundsPlaying, :GetSoundsPlaying, [], :int],

      # IsSoundPlaying : Check if a sound is currently playing
      # @param sound [Sound]
      # @return [bool]
      [:IsSoundPlaying, :IsSoundPlaying, [Sound.by_value], :bool],

      # SetSoundVolume : Set volume for a sound (1.0 is max level)
      # @param sound [Sound]
      # @param volume [float]
      # @return [void]
      [:SetSoundVolume, :SetSoundVolume, [Sound.by_value, :float], :void],

      # SetSoundPitch : Set pitch for a sound (1.0 is base level)
      # @param sound [Sound]
      # @param pitch [float]
      # @return [void]
      [:SetSoundPitch, :SetSoundPitch, [Sound.by_value, :float], :void],

      # SetSoundPan : Set pan for a sound (0.5 is center)
      # @param sound [Sound]
      # @param pan [float]
      # @return [void]
      [:SetSoundPan, :SetSoundPan, [Sound.by_value, :float], :void],

      # WaveCopy : Copy a wave to a new wave
      # @param wave [Wave]
      # @return [Wave]
      [:WaveCopy, :WaveCopy, [Wave.by_value], Wave.by_value],

      # WaveCrop : Crop a wave to defined samples range
      # @param wave [Wave *]
      # @param initSample [int]
      # @param finalSample [int]
      # @return [void]
      [:WaveCrop, :WaveCrop, [:pointer, :int, :int], :void],

      # WaveFormat : Convert wave data to desired format
      # @param wave [Wave *]
      # @param sampleRate [int]
      # @param sampleSize [int]
      # @param channels [int]
      # @return [void]
      [:WaveFormat, :WaveFormat, [:pointer, :int, :int, :int], :void],

      # LoadWaveSamples : Load samples data from wave as a 32bit float data array
      # @param wave [Wave]
      # @return [float *]
      [:LoadWaveSamples, :LoadWaveSamples, [Wave.by_value], :pointer],

      # UnloadWaveSamples : Unload samples data loaded with LoadWaveSamples()
      # @param samples [float *]
      # @return [void]
      [:UnloadWaveSamples, :UnloadWaveSamples, [:pointer], :void],

      # LoadMusicStream : Load music stream from file
      # @param fileName [const char *]
      # @return [Music]
      [:LoadMusicStream, :LoadMusicStream, [:pointer], Music.by_value],

      # LoadMusicStreamFromMemory : Load music stream from data
      # @param fileType [const char *]
      # @param data [const unsigned char *]
      # @param dataSize [int]
      # @return [Music]
      [:LoadMusicStreamFromMemory, :LoadMusicStreamFromMemory, [:pointer, :pointer, :int], Music.by_value],

      # UnloadMusicStream : Unload music stream
      # @param music [Music]
      # @return [void]
      [:UnloadMusicStream, :UnloadMusicStream, [Music.by_value], :void],

      # PlayMusicStream : Start music playing
      # @param music [Music]
      # @return [void]
      [:PlayMusicStream, :PlayMusicStream, [Music.by_value], :void],

      # IsMusicStreamPlaying : Check if music is playing
      # @param music [Music]
      # @return [bool]
      [:IsMusicStreamPlaying, :IsMusicStreamPlaying, [Music.by_value], :bool],

      # UpdateMusicStream : Updates buffers for music streaming
      # @param music [Music]
      # @return [void]
      [:UpdateMusicStream, :UpdateMusicStream, [Music.by_value], :void],

      # StopMusicStream : Stop music playing
      # @param music [Music]
      # @return [void]
      [:StopMusicStream, :StopMusicStream, [Music.by_value], :void],

      # PauseMusicStream : Pause music playing
      # @param music [Music]
      # @return [void]
      [:PauseMusicStream, :PauseMusicStream, [Music.by_value], :void],

      # ResumeMusicStream : Resume playing paused music
      # @param music [Music]
      # @return [void]
      [:ResumeMusicStream, :ResumeMusicStream, [Music.by_value], :void],

      # SeekMusicStream : Seek music to a position (in seconds)
      # @param music [Music]
      # @param position [float]
      # @return [void]
      [:SeekMusicStream, :SeekMusicStream, [Music.by_value, :float], :void],

      # SetMusicVolume : Set volume for music (1.0 is max level)
      # @param music [Music]
      # @param volume [float]
      # @return [void]
      [:SetMusicVolume, :SetMusicVolume, [Music.by_value, :float], :void],

      # SetMusicPitch : Set pitch for a music (1.0 is base level)
      # @param music [Music]
      # @param pitch [float]
      # @return [void]
      [:SetMusicPitch, :SetMusicPitch, [Music.by_value, :float], :void],

      # SetMusicPan : Set pan for a music (0.5 is center)
      # @param music [Music]
      # @param pan [float]
      # @return [void]
      [:SetMusicPan, :SetMusicPan, [Music.by_value, :float], :void],

      # GetMusicTimeLength : Get music time length (in seconds)
      # @param music [Music]
      # @return [float]
      [:GetMusicTimeLength, :GetMusicTimeLength, [Music.by_value], :float],

      # GetMusicTimePlayed : Get current music time played (in seconds)
      # @param music [Music]
      # @return [float]
      [:GetMusicTimePlayed, :GetMusicTimePlayed, [Music.by_value], :float],

      # LoadAudioStream : Load audio stream (to stream raw audio pcm data)
      # @param sampleRate [unsigned int]
      # @param sampleSize [unsigned int]
      # @param channels [unsigned int]
      # @return [AudioStream]
      [:LoadAudioStream, :LoadAudioStream, [:uint, :uint, :uint], AudioStream.by_value],

      # UnloadAudioStream : Unload audio stream and free memory
      # @param stream [AudioStream]
      # @return [void]
      [:UnloadAudioStream, :UnloadAudioStream, [AudioStream.by_value], :void],

      # UpdateAudioStream : Update audio stream buffers with data
      # @param stream [AudioStream]
      # @param data [const void *]
      # @param frameCount [int]
      # @return [void]
      [:UpdateAudioStream, :UpdateAudioStream, [AudioStream.by_value, :pointer, :int], :void],

      # IsAudioStreamProcessed : Check if any audio stream buffers requires refill
      # @param stream [AudioStream]
      # @return [bool]
      [:IsAudioStreamProcessed, :IsAudioStreamProcessed, [AudioStream.by_value], :bool],

      # PlayAudioStream : Play audio stream
      # @param stream [AudioStream]
      # @return [void]
      [:PlayAudioStream, :PlayAudioStream, [AudioStream.by_value], :void],

      # PauseAudioStream : Pause audio stream
      # @param stream [AudioStream]
      # @return [void]
      [:PauseAudioStream, :PauseAudioStream, [AudioStream.by_value], :void],

      # ResumeAudioStream : Resume audio stream
      # @param stream [AudioStream]
      # @return [void]
      [:ResumeAudioStream, :ResumeAudioStream, [AudioStream.by_value], :void],

      # IsAudioStreamPlaying : Check if audio stream is playing
      # @param stream [AudioStream]
      # @return [bool]
      [:IsAudioStreamPlaying, :IsAudioStreamPlaying, [AudioStream.by_value], :bool],

      # StopAudioStream : Stop audio stream
      # @param stream [AudioStream]
      # @return [void]
      [:StopAudioStream, :StopAudioStream, [AudioStream.by_value], :void],

      # SetAudioStreamVolume : Set volume for audio stream (1.0 is max level)
      # @param stream [AudioStream]
      # @param volume [float]
      # @return [void]
      [:SetAudioStreamVolume, :SetAudioStreamVolume, [AudioStream.by_value, :float], :void],

      # SetAudioStreamPitch : Set pitch for audio stream (1.0 is base level)
      # @param stream [AudioStream]
      # @param pitch [float]
      # @return [void]
      [:SetAudioStreamPitch, :SetAudioStreamPitch, [AudioStream.by_value, :float], :void],

      # SetAudioStreamPan : Set pan for audio stream (0.5 is centered)
      # @param stream [AudioStream]
      # @param pan [float]
      # @return [void]
      [:SetAudioStreamPan, :SetAudioStreamPan, [AudioStream.by_value, :float], :void],

      # SetAudioStreamBufferSizeDefault : Default size for new audio streams
      # @param size [int]
      # @return [void]
      [:SetAudioStreamBufferSizeDefault, :SetAudioStreamBufferSizeDefault, [:int], :void],

      # SetAudioStreamCallback : Audio thread callback to request new data
      # @param stream [AudioStream]
      # @param callback [AudioCallback]
      # @return [void]
      [:SetAudioStreamCallback, :SetAudioStreamCallback, [AudioStream.by_value, :AudioCallback], :void],

      # AttachAudioStreamProcessor : Attach audio stream processor to stream
      # @param stream [AudioStream]
      # @param processor [AudioCallback]
      # @return [void]
      [:AttachAudioStreamProcessor, :AttachAudioStreamProcessor, [AudioStream.by_value, :AudioCallback], :void],

      # DetachAudioStreamProcessor : Detach audio stream processor from stream
      # @param stream [AudioStream]
      # @param processor [AudioCallback]
      # @return [void]
      [:DetachAudioStreamProcessor, :DetachAudioStreamProcessor, [AudioStream.by_value, :AudioCallback], :void],
    ]
    entries.each do |entry|
      attach_function entry[0], entry[1], entry[2], entry[3]
    rescue FFI::NotFoundError => e
      warn "[Warning] Failed to import #{entry[0]} (#{e})."
    end
  end
end
