# Yet another raylib wrapper for Ruby
#
# * https://github.com/vaiorabbit/raylib-bindings
#
# [NOTICE] Autogenerated. Do not edit.

require 'ffi'

module Raylib
  extend FFI::Library

  # Define/Macro

  RLGL_VERSION = "4.0"
  RL_DEFAULT_BATCH_BUFFER_ELEMENTS = 8192
  RL_TEXTURE_WRAP_S = 0x2802 # GL_TEXTURE_WRAP_S
  RL_TEXTURE_WRAP_T = 0x2803 # GL_TEXTURE_WRAP_T
  RL_TEXTURE_MAG_FILTER = 0x2800 # GL_TEXTURE_MAG_FILTER
  RL_TEXTURE_MIN_FILTER = 0x2801 # GL_TEXTURE_MIN_FILTER
  RL_TEXTURE_FILTER_NEAREST = 0x2600 # GL_NEAREST
  RL_TEXTURE_FILTER_LINEAR = 0x2601 # GL_LINEAR
  RL_TEXTURE_FILTER_MIP_NEAREST = 0x2700 # GL_NEAREST_MIPMAP_NEAREST
  RL_TEXTURE_FILTER_NEAREST_MIP_LINEAR = 0x2702 # GL_NEAREST_MIPMAP_LINEAR
  RL_TEXTURE_FILTER_LINEAR_MIP_NEAREST = 0x2701 # GL_LINEAR_MIPMAP_NEAREST
  RL_TEXTURE_FILTER_MIP_LINEAR = 0x2703 # GL_LINEAR_MIPMAP_LINEAR
  RL_TEXTURE_FILTER_ANISOTROPIC = 0x3000 # Anisotropic filter (custom identifier)
  RL_TEXTURE_MIPMAP_BIAS_RATIO = 0x4000 # Texture mipmap bias, percentage ratio (custom identifier)
  RL_TEXTURE_WRAP_REPEAT = 0x2901 # GL_REPEAT
  RL_TEXTURE_WRAP_CLAMP = 0x812F # GL_CLAMP_TO_EDGE
  RL_TEXTURE_WRAP_MIRROR_REPEAT = 0x8370 # GL_MIRRORED_REPEAT
  RL_TEXTURE_WRAP_MIRROR_CLAMP = 0x8742 # GL_MIRROR_CLAMP_EXT
  RL_MODELVIEW = 0x1700 # GL_MODELVIEW
  RL_PROJECTION = 0x1701 # GL_PROJECTION
  RL_TEXTURE = 0x1702 # GL_TEXTURE
  RL_LINES = 0x0001 # GL_LINES
  RL_TRIANGLES = 0x0004 # GL_TRIANGLES
  RL_QUADS = 0x0007 # GL_QUADS
  RL_UNSIGNED_BYTE = 0x1401 # GL_UNSIGNED_BYTE
  RL_FLOAT = 0x1406 # GL_FLOAT
  RL_STREAM_DRAW = 0x88E0 # GL_STREAM_DRAW
  RL_STREAM_READ = 0x88E1 # GL_STREAM_READ
  RL_STREAM_COPY = 0x88E2 # GL_STREAM_COPY
  RL_STATIC_DRAW = 0x88E4 # GL_STATIC_DRAW
  RL_STATIC_READ = 0x88E5 # GL_STATIC_READ
  RL_STATIC_COPY = 0x88E6 # GL_STATIC_COPY
  RL_DYNAMIC_DRAW = 0x88E8 # GL_DYNAMIC_DRAW
  RL_DYNAMIC_READ = 0x88E9 # GL_DYNAMIC_READ
  RL_DYNAMIC_COPY = 0x88EA # GL_DYNAMIC_COPY
  RL_FRAGMENT_SHADER = 0x8B30 # GL_FRAGMENT_SHADER
  RL_VERTEX_SHADER = 0x8B31 # GL_VERTEX_SHADER
  RL_COMPUTE_SHADER = 0x91B9 # GL_COMPUTE_SHADER
  RL_ZERO = 0 # GL_ZERO
  RL_ONE = 1 # GL_ONE
  RL_SRC_COLOR = 0x0300 # GL_SRC_COLOR
  RL_ONE_MINUS_SRC_COLOR = 0x0301 # GL_ONE_MINUS_SRC_COLOR
  RL_SRC_ALPHA = 0x0302 # GL_SRC_ALPHA
  RL_ONE_MINUS_SRC_ALPHA = 0x0303 # GL_ONE_MINUS_SRC_ALPHA
  RL_DST_ALPHA = 0x0304 # GL_DST_ALPHA
  RL_ONE_MINUS_DST_ALPHA = 0x0305 # GL_ONE_MINUS_DST_ALPHA
  RL_DST_COLOR = 0x0306 # GL_DST_COLOR
  RL_ONE_MINUS_DST_COLOR = 0x0307 # GL_ONE_MINUS_DST_COLOR
  RL_SRC_ALPHA_SATURATE = 0x0308 # GL_SRC_ALPHA_SATURATE
  RL_CONSTANT_COLOR = 0x8001 # GL_CONSTANT_COLOR
  RL_ONE_MINUS_CONSTANT_COLOR = 0x8002 # GL_ONE_MINUS_CONSTANT_COLOR
  RL_CONSTANT_ALPHA = 0x8003 # GL_CONSTANT_ALPHA
  RL_ONE_MINUS_CONSTANT_ALPHA = 0x8004 # GL_ONE_MINUS_CONSTANT_ALPHA
  RL_FUNC_ADD = 0x8006 # GL_FUNC_ADD
  RL_FUNC_SUBTRACT = 0x800A # GL_FUNC_SUBTRACT
  RL_FUNC_REVERSE_SUBTRACT = 0x800B # GL_FUNC_REVERSE_SUBTRACT
  RL_BLEND_EQUATION = 0x8009 # GL_BLEND_EQUATION
  RL_BLEND_EQUATION_RGB = 0x8009 # GL_BLEND_EQUATION_RGB   // (Same as BLEND_EQUATION)
  RL_BLEND_EQUATION_ALPHA = 0x883D # GL_BLEND_EQUATION_ALPHA
  RL_BLEND_DST_RGB = 0x80C8 # GL_BLEND_DST_RGB
  RL_BLEND_SRC_RGB = 0x80C9 # GL_BLEND_SRC_RGB
  RL_BLEND_DST_ALPHA = 0x80CA # GL_BLEND_DST_ALPHA
  RL_BLEND_SRC_ALPHA = 0x80CB # GL_BLEND_SRC_ALPHA
  RL_BLEND_COLOR = 0x8005 # GL_BLEND_COLOR

  # Enum

  # enum rlGlVersion
  # OpenGL version
  RL_OPENGL_11 = 1 # OpenGL 1.1
  RL_OPENGL_21 = 2 # OpenGL 2.1 (GLSL 120)
  RL_OPENGL_33 = 3 # OpenGL 3.3 (GLSL 330)
  RL_OPENGL_43 = 4 # OpenGL 4.3 (using GLSL 330)
  RL_OPENGL_ES_20 = 5 # OpenGL ES 2.0 (GLSL 100)

  # enum rlTraceLogLevel
  # Trace log level
  RL_LOG_ALL = 0 # Display all logs
  RL_LOG_TRACE = 1 # Trace logging, intended for internal use only
  RL_LOG_DEBUG = 2 # Debug logging, used for internal debugging, it should be disabled on release builds
  RL_LOG_INFO = 3 # Info logging, used for program execution info
  RL_LOG_WARNING = 4 # Warning logging, used on recoverable failures
  RL_LOG_ERROR = 5 # Error logging, used on unrecoverable failures
  RL_LOG_FATAL = 6 # Fatal logging, used to abort program: exit(EXIT_FAILURE)
  RL_LOG_NONE = 7 # Disable logging

  # enum rlPixelFormat
  # Texture pixel formats
  RL_PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = 1 # 8 bit per pixel (no alpha)
  RL_PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA = 2 # 8*2 bpp (2 channels)
  RL_PIXELFORMAT_UNCOMPRESSED_R5G6B5 = 3 # 16 bpp
  RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8 = 4 # 24 bpp
  RL_PIXELFORMAT_UNCOMPRESSED_R5G5B5A1 = 5 # 16 bpp (1 bit alpha)
  RL_PIXELFORMAT_UNCOMPRESSED_R4G4B4A4 = 6 # 16 bpp (4 bit alpha)
  RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 = 7 # 32 bpp
  RL_PIXELFORMAT_UNCOMPRESSED_R32 = 8 # 32 bpp (1 channel - float)
  RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32 = 9 # 32*3 bpp (3 channels - float)
  RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32A32 = 10 # 32*4 bpp (4 channels - float)
  RL_PIXELFORMAT_COMPRESSED_DXT1_RGB = 11 # 4 bpp (no alpha)
  RL_PIXELFORMAT_COMPRESSED_DXT1_RGBA = 12 # 4 bpp (1 bit alpha)
  RL_PIXELFORMAT_COMPRESSED_DXT3_RGBA = 13 # 8 bpp
  RL_PIXELFORMAT_COMPRESSED_DXT5_RGBA = 14 # 8 bpp
  RL_PIXELFORMAT_COMPRESSED_ETC1_RGB = 15 # 4 bpp
  RL_PIXELFORMAT_COMPRESSED_ETC2_RGB = 16 # 4 bpp
  RL_PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA = 17 # 8 bpp
  RL_PIXELFORMAT_COMPRESSED_PVRT_RGB = 18 # 4 bpp
  RL_PIXELFORMAT_COMPRESSED_PVRT_RGBA = 19 # 4 bpp
  RL_PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA = 20 # 8 bpp
  RL_PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA = 21 # 2 bpp

  # enum rlTextureFilter
  # Texture parameters: filter mode
  RL_TEXTURE_FILTER_POINT = 0 # No filter, just pixel approximation
  RL_TEXTURE_FILTER_BILINEAR = 1 # Linear filtering
  RL_TEXTURE_FILTER_TRILINEAR = 2 # Trilinear filtering (linear with mipmaps)
  RL_TEXTURE_FILTER_ANISOTROPIC_4X = 3 # Anisotropic filtering 4x
  RL_TEXTURE_FILTER_ANISOTROPIC_8X = 4 # Anisotropic filtering 8x
  RL_TEXTURE_FILTER_ANISOTROPIC_16X = 5 # Anisotropic filtering 16x

  # enum rlBlendMode
  # Color blending modes (pre-defined)
  RL_BLEND_ALPHA = 0 # Blend textures considering alpha (default)
  RL_BLEND_ADDITIVE = 1 # Blend textures adding colors
  RL_BLEND_MULTIPLIED = 2 # Blend textures multiplying colors
  RL_BLEND_ADD_COLORS = 3 # Blend textures adding colors (alternative)
  RL_BLEND_SUBTRACT_COLORS = 4 # Blend textures subtracting colors (alternative)
  RL_BLEND_ALPHA_PREMULTIPLY = 5 # Blend premultiplied textures considering alpha
  RL_BLEND_CUSTOM = 6 # Blend textures using custom src/dst factors (use rlSetBlendFactors())
  RL_BLEND_CUSTOM_SEPARATE = 7 # Blend textures using custom src/dst factors (use rlSetBlendFactorsSeparate())

  # enum rlShaderLocationIndex
  # Shader location point type
  RL_SHADER_LOC_VERTEX_POSITION = 0 # Shader location: vertex attribute: position
  RL_SHADER_LOC_VERTEX_TEXCOORD01 = 1 # Shader location: vertex attribute: texcoord01
  RL_SHADER_LOC_VERTEX_TEXCOORD02 = 2 # Shader location: vertex attribute: texcoord02
  RL_SHADER_LOC_VERTEX_NORMAL = 3 # Shader location: vertex attribute: normal
  RL_SHADER_LOC_VERTEX_TANGENT = 4 # Shader location: vertex attribute: tangent
  RL_SHADER_LOC_VERTEX_COLOR = 5 # Shader location: vertex attribute: color
  RL_SHADER_LOC_MATRIX_MVP = 6 # Shader location: matrix uniform: model-view-projection
  RL_SHADER_LOC_MATRIX_VIEW = 7 # Shader location: matrix uniform: view (camera transform)
  RL_SHADER_LOC_MATRIX_PROJECTION = 8 # Shader location: matrix uniform: projection
  RL_SHADER_LOC_MATRIX_MODEL = 9 # Shader location: matrix uniform: model (transform)
  RL_SHADER_LOC_MATRIX_NORMAL = 10 # Shader location: matrix uniform: normal
  RL_SHADER_LOC_VECTOR_VIEW = 11 # Shader location: vector uniform: view
  RL_SHADER_LOC_COLOR_DIFFUSE = 12 # Shader location: vector uniform: diffuse color
  RL_SHADER_LOC_COLOR_SPECULAR = 13 # Shader location: vector uniform: specular color
  RL_SHADER_LOC_COLOR_AMBIENT = 14 # Shader location: vector uniform: ambient color
  RL_SHADER_LOC_MAP_ALBEDO = 15 # Shader location: sampler2d texture: albedo (same as: RL_SHADER_LOC_MAP_DIFFUSE)
  RL_SHADER_LOC_MAP_METALNESS = 16 # Shader location: sampler2d texture: metalness (same as: RL_SHADER_LOC_MAP_SPECULAR)
  RL_SHADER_LOC_MAP_NORMAL = 17 # Shader location: sampler2d texture: normal
  RL_SHADER_LOC_MAP_ROUGHNESS = 18 # Shader location: sampler2d texture: roughness
  RL_SHADER_LOC_MAP_OCCLUSION = 19 # Shader location: sampler2d texture: occlusion
  RL_SHADER_LOC_MAP_EMISSION = 20 # Shader location: sampler2d texture: emission
  RL_SHADER_LOC_MAP_HEIGHT = 21 # Shader location: sampler2d texture: height
  RL_SHADER_LOC_MAP_CUBEMAP = 22 # Shader location: samplerCube texture: cubemap
  RL_SHADER_LOC_MAP_IRRADIANCE = 23 # Shader location: samplerCube texture: irradiance
  RL_SHADER_LOC_MAP_PREFILTER = 24 # Shader location: samplerCube texture: prefilter
  RL_SHADER_LOC_MAP_BRDF = 25 # Shader location: sampler2d texture: brdf

  # enum rlShaderUniformDataType
  # Shader uniform data type
  RL_SHADER_UNIFORM_FLOAT = 0 # Shader uniform type: float
  RL_SHADER_UNIFORM_VEC2 = 1 # Shader uniform type: vec2 (2 float)
  RL_SHADER_UNIFORM_VEC3 = 2 # Shader uniform type: vec3 (3 float)
  RL_SHADER_UNIFORM_VEC4 = 3 # Shader uniform type: vec4 (4 float)
  RL_SHADER_UNIFORM_INT = 4 # Shader uniform type: int
  RL_SHADER_UNIFORM_IVEC2 = 5 # Shader uniform type: ivec2 (2 int)
  RL_SHADER_UNIFORM_IVEC3 = 6 # Shader uniform type: ivec3 (3 int)
  RL_SHADER_UNIFORM_IVEC4 = 7 # Shader uniform type: ivec4 (4 int)
  RL_SHADER_UNIFORM_SAMPLER2D = 8 # Shader uniform type: sampler2d

  # enum rlShaderAttributeDataType
  # Shader attribute data types
  RL_SHADER_ATTRIB_FLOAT = 0 # Shader attribute type: float
  RL_SHADER_ATTRIB_VEC2 = 1 # Shader attribute type: vec2 (2 float)
  RL_SHADER_ATTRIB_VEC3 = 2 # Shader attribute type: vec3 (3 float)
  RL_SHADER_ATTRIB_VEC4 = 3 # Shader attribute type: vec4 (4 float)

  # enum rlFramebufferAttachType
  # Framebuffer attachment type
  RL_ATTACHMENT_COLOR_CHANNEL0 = 0 # Framebuffer attachmment type: color 0
  RL_ATTACHMENT_COLOR_CHANNEL1 = 1 # Framebuffer attachmment type: color 1
  RL_ATTACHMENT_COLOR_CHANNEL2 = 2 # Framebuffer attachmment type: color 2
  RL_ATTACHMENT_COLOR_CHANNEL3 = 3 # Framebuffer attachmment type: color 3
  RL_ATTACHMENT_COLOR_CHANNEL4 = 4 # Framebuffer attachmment type: color 4
  RL_ATTACHMENT_COLOR_CHANNEL5 = 5 # Framebuffer attachmment type: color 5
  RL_ATTACHMENT_COLOR_CHANNEL6 = 6 # Framebuffer attachmment type: color 6
  RL_ATTACHMENT_COLOR_CHANNEL7 = 7 # Framebuffer attachmment type: color 7
  RL_ATTACHMENT_DEPTH = 100 # Framebuffer attachmment type: depth
  RL_ATTACHMENT_STENCIL = 200 # Framebuffer attachmment type: stencil

  # enum rlFramebufferAttachTextureType
  # Framebuffer texture attachment type
  RL_ATTACHMENT_CUBEMAP_POSITIVE_X = 0 # Framebuffer texture attachment type: cubemap, +X side
  RL_ATTACHMENT_CUBEMAP_NEGATIVE_X = 1 # Framebuffer texture attachment type: cubemap, -X side
  RL_ATTACHMENT_CUBEMAP_POSITIVE_Y = 2 # Framebuffer texture attachment type: cubemap, +Y side
  RL_ATTACHMENT_CUBEMAP_NEGATIVE_Y = 3 # Framebuffer texture attachment type: cubemap, -Y side
  RL_ATTACHMENT_CUBEMAP_POSITIVE_Z = 4 # Framebuffer texture attachment type: cubemap, +Z side
  RL_ATTACHMENT_CUBEMAP_NEGATIVE_Z = 5 # Framebuffer texture attachment type: cubemap, -Z side
  RL_ATTACHMENT_TEXTURE2D = 100 # Framebuffer texture attachment type: texture2d
  RL_ATTACHMENT_RENDERBUFFER = 200 # Framebuffer texture attachment type: renderbuffer

  # enum rlCullMode
  # Face culling mode
  RL_CULL_FACE_FRONT = 0
  RL_CULL_FACE_BACK = 1


  # Typedef

  typedef :int, :rlGlVersion
  typedef :int, :rlTraceLogLevel
  typedef :int, :rlPixelFormat
  typedef :int, :rlTextureFilter
  typedef :int, :rlBlendMode
  typedef :int, :rlShaderLocationIndex
  typedef :int, :rlShaderUniformDataType
  typedef :int, :rlShaderAttributeDataType
  typedef :int, :rlFramebufferAttachType
  typedef :int, :rlFramebufferAttachTextureType
  typedef :int, :rlCullMode

  # Struct

  # Dynamic vertex buffers (position + texcoords + colors + indices arrays)
  class RlVertexBuffer < FFI::Struct
    layout(
      :elementCount, :int, # Number of elements in the buffer (QUADS)
      :vertices, :pointer, # Vertex position (XYZ - 3 components per vertex) (shader-location = 0)
      :texcoords, :pointer, # Vertex texture coordinates (UV - 2 components per vertex) (shader-location = 1)
      :colors, :pointer, # Vertex colors (RGBA - 4 components per vertex) (shader-location = 3)
      :indices, :pointer, # Vertex indices (in case vertex data comes indexed) (6 indices per quad)
      :vaoId, :uint, # OpenGL Vertex Array Object id
      :vboId, [:uint, 4], # OpenGL Vertex Buffer Objects id (4 types of vertex data)
    )
  end

  # of those state-change happens (this is done in core module)
  class RlDrawCall < FFI::Struct
    layout(
      :mode, :int, # Drawing mode: LINES, TRIANGLES, QUADS
      :vertexCount, :int, # Number of vertex of the draw
      :vertexAlignment, :int, # Number of vertex required for index alignment (LINES, TRIANGLES)
      :textureId, :uint, # Texture id to be used on the draw -> Use to create new draw call if changes
    )
  end

  # rlRenderBatch type
  class RlRenderBatch < FFI::Struct
    layout(
      :bufferCount, :int, # Number of vertex buffers (multi-buffering support)
      :currentBuffer, :int, # Current buffer tracking in case of multi-buffering
      :vertexBuffer, :pointer, # Dynamic buffer(s) for vertex data
      :draws, :pointer, # Draw calls array, depends on textureId
      :drawCounter, :int, # Draw calls counter
      :currentDepth, :float, # Current depth value for next draw
    )
  end


  # Function

  def self.setup_rlgl_symbols
    entries = [

      # rlMatrixMode : Choose the current matrix to be transformed
      # @param mode [int]
      # @return [void]
      [:rlMatrixMode, :rlMatrixMode, [:int], :void],

      # rlPushMatrix : Push the current matrix to stack
      # @return [void]
      [:rlPushMatrix, :rlPushMatrix, [], :void],

      # rlPopMatrix : Pop lattest inserted matrix from stack
      # @return [void]
      [:rlPopMatrix, :rlPopMatrix, [], :void],

      # rlLoadIdentity : Reset current matrix to identity matrix
      # @return [void]
      [:rlLoadIdentity, :rlLoadIdentity, [], :void],

      # rlTranslatef : Multiply the current matrix by a translation matrix
      # @param x [float]
      # @param y [float]
      # @param z [float]
      # @return [void]
      [:rlTranslatef, :rlTranslatef, [:float, :float, :float], :void],

      # rlRotatef : Multiply the current matrix by a rotation matrix
      # @param angle [float]
      # @param x [float]
      # @param y [float]
      # @param z [float]
      # @return [void]
      [:rlRotatef, :rlRotatef, [:float, :float, :float, :float], :void],

      # rlScalef : Multiply the current matrix by a scaling matrix
      # @param x [float]
      # @param y [float]
      # @param z [float]
      # @return [void]
      [:rlScalef, :rlScalef, [:float, :float, :float], :void],

      # rlMultMatrixf : Multiply the current matrix by another matrix
      # @param matf [const float *]
      # @return [void]
      [:rlMultMatrixf, :rlMultMatrixf, [:pointer], :void],

      # rlFrustum
      # @param left [double]
      # @param right [double]
      # @param bottom [double]
      # @param top [double]
      # @param znear [double]
      # @param zfar [double]
      # @return [void]
      [:rlFrustum, :rlFrustum, [:double, :double, :double, :double, :double, :double], :void],

      # rlOrtho
      # @param left [double]
      # @param right [double]
      # @param bottom [double]
      # @param top [double]
      # @param znear [double]
      # @param zfar [double]
      # @return [void]
      [:rlOrtho, :rlOrtho, [:double, :double, :double, :double, :double, :double], :void],

      # rlViewport : Set the viewport area
      # @param x [int]
      # @param y [int]
      # @param width [int]
      # @param height [int]
      # @return [void]
      [:rlViewport, :rlViewport, [:int, :int, :int, :int], :void],

      # rlBegin : Initialize drawing mode (how to organize vertex)
      # @param mode [int]
      # @return [void]
      [:rlBegin, :rlBegin, [:int], :void],

      # rlEnd : Finish vertex providing
      # @return [void]
      [:rlEnd, :rlEnd, [], :void],

      # rlVertex2i : Define one vertex (position) - 2 int
      # @param x [int]
      # @param y [int]
      # @return [void]
      [:rlVertex2i, :rlVertex2i, [:int, :int], :void],

      # rlVertex2f : Define one vertex (position) - 2 float
      # @param x [float]
      # @param y [float]
      # @return [void]
      [:rlVertex2f, :rlVertex2f, [:float, :float], :void],

      # rlVertex3f : Define one vertex (position) - 3 float
      # @param x [float]
      # @param y [float]
      # @param z [float]
      # @return [void]
      [:rlVertex3f, :rlVertex3f, [:float, :float, :float], :void],

      # rlTexCoord2f : Define one vertex (texture coordinate) - 2 float
      # @param x [float]
      # @param y [float]
      # @return [void]
      [:rlTexCoord2f, :rlTexCoord2f, [:float, :float], :void],

      # rlNormal3f : Define one vertex (normal) - 3 float
      # @param x [float]
      # @param y [float]
      # @param z [float]
      # @return [void]
      [:rlNormal3f, :rlNormal3f, [:float, :float, :float], :void],

      # rlColor4ub : Define one vertex (color) - 4 byte
      # @param r [unsigned char]
      # @param g [unsigned char]
      # @param b [unsigned char]
      # @param a [unsigned char]
      # @return [void]
      [:rlColor4ub, :rlColor4ub, [:uchar, :uchar, :uchar, :uchar], :void],

      # rlColor3f : Define one vertex (color) - 3 float
      # @param x [float]
      # @param y [float]
      # @param z [float]
      # @return [void]
      [:rlColor3f, :rlColor3f, [:float, :float, :float], :void],

      # rlColor4f : Define one vertex (color) - 4 float
      # @param x [float]
      # @param y [float]
      # @param z [float]
      # @param w [float]
      # @return [void]
      [:rlColor4f, :rlColor4f, [:float, :float, :float, :float], :void],

      # rlEnableVertexArray : Enable vertex array (VAO, if supported)
      # @param vaoId [unsigned int]
      # @return [bool]
      [:rlEnableVertexArray, :rlEnableVertexArray, [:uint], :bool],

      # rlDisableVertexArray : Disable vertex array (VAO, if supported)
      # @return [void]
      [:rlDisableVertexArray, :rlDisableVertexArray, [], :void],

      # rlEnableVertexBuffer : Enable vertex buffer (VBO)
      # @param id [unsigned int]
      # @return [void]
      [:rlEnableVertexBuffer, :rlEnableVertexBuffer, [:uint], :void],

      # rlDisableVertexBuffer : Disable vertex buffer (VBO)
      # @return [void]
      [:rlDisableVertexBuffer, :rlDisableVertexBuffer, [], :void],

      # rlEnableVertexBufferElement : Enable vertex buffer element (VBO element)
      # @param id [unsigned int]
      # @return [void]
      [:rlEnableVertexBufferElement, :rlEnableVertexBufferElement, [:uint], :void],

      # rlDisableVertexBufferElement : Disable vertex buffer element (VBO element)
      # @return [void]
      [:rlDisableVertexBufferElement, :rlDisableVertexBufferElement, [], :void],

      # rlEnableVertexAttribute : Enable vertex attribute index
      # @param index [unsigned int]
      # @return [void]
      [:rlEnableVertexAttribute, :rlEnableVertexAttribute, [:uint], :void],

      # rlDisableVertexAttribute : Disable vertex attribute index
      # @param index [unsigned int]
      # @return [void]
      [:rlDisableVertexAttribute, :rlDisableVertexAttribute, [:uint], :void],

      # rlActiveTextureSlot : Select and active a texture slot
      # @param slot [int]
      # @return [void]
      [:rlActiveTextureSlot, :rlActiveTextureSlot, [:int], :void],

      # rlEnableTexture : Enable texture
      # @param id [unsigned int]
      # @return [void]
      [:rlEnableTexture, :rlEnableTexture, [:uint], :void],

      # rlDisableTexture : Disable texture
      # @return [void]
      [:rlDisableTexture, :rlDisableTexture, [], :void],

      # rlEnableTextureCubemap : Enable texture cubemap
      # @param id [unsigned int]
      # @return [void]
      [:rlEnableTextureCubemap, :rlEnableTextureCubemap, [:uint], :void],

      # rlDisableTextureCubemap : Disable texture cubemap
      # @return [void]
      [:rlDisableTextureCubemap, :rlDisableTextureCubemap, [], :void],

      # rlTextureParameters : Set texture parameters (filter, wrap)
      # @param id [unsigned int]
      # @param param [int]
      # @param value [int]
      # @return [void]
      [:rlTextureParameters, :rlTextureParameters, [:uint, :int, :int], :void],

      # rlEnableShader : Enable shader program
      # @param id [unsigned int]
      # @return [void]
      [:rlEnableShader, :rlEnableShader, [:uint], :void],

      # rlDisableShader : Disable shader program
      # @return [void]
      [:rlDisableShader, :rlDisableShader, [], :void],

      # rlEnableFramebuffer : Enable render texture (fbo)
      # @param id [unsigned int]
      # @return [void]
      [:rlEnableFramebuffer, :rlEnableFramebuffer, [:uint], :void],

      # rlDisableFramebuffer : Disable render texture (fbo), return to default framebuffer
      # @return [void]
      [:rlDisableFramebuffer, :rlDisableFramebuffer, [], :void],

      # rlActiveDrawBuffers : Activate multiple draw color buffers
      # @param count [int]
      # @return [void]
      [:rlActiveDrawBuffers, :rlActiveDrawBuffers, [:int], :void],

      # rlEnableColorBlend : Enable color blending
      # @return [void]
      [:rlEnableColorBlend, :rlEnableColorBlend, [], :void],

      # rlDisableColorBlend : Disable color blending
      # @return [void]
      [:rlDisableColorBlend, :rlDisableColorBlend, [], :void],

      # rlEnableDepthTest : Enable depth test
      # @return [void]
      [:rlEnableDepthTest, :rlEnableDepthTest, [], :void],

      # rlDisableDepthTest : Disable depth test
      # @return [void]
      [:rlDisableDepthTest, :rlDisableDepthTest, [], :void],

      # rlEnableDepthMask : Enable depth write
      # @return [void]
      [:rlEnableDepthMask, :rlEnableDepthMask, [], :void],

      # rlDisableDepthMask : Disable depth write
      # @return [void]
      [:rlDisableDepthMask, :rlDisableDepthMask, [], :void],

      # rlEnableBackfaceCulling : Enable backface culling
      # @return [void]
      [:rlEnableBackfaceCulling, :rlEnableBackfaceCulling, [], :void],

      # rlDisableBackfaceCulling : Disable backface culling
      # @return [void]
      [:rlDisableBackfaceCulling, :rlDisableBackfaceCulling, [], :void],

      # rlSetCullFace : Set face culling mode
      # @param mode [int]
      # @return [void]
      [:rlSetCullFace, :rlSetCullFace, [:int], :void],

      # rlEnableScissorTest : Enable scissor test
      # @return [void]
      [:rlEnableScissorTest, :rlEnableScissorTest, [], :void],

      # rlDisableScissorTest : Disable scissor test
      # @return [void]
      [:rlDisableScissorTest, :rlDisableScissorTest, [], :void],

      # rlScissor : Scissor test
      # @param x [int]
      # @param y [int]
      # @param width [int]
      # @param height [int]
      # @return [void]
      [:rlScissor, :rlScissor, [:int, :int, :int, :int], :void],

      # rlEnableWireMode : Enable wire mode
      # @return [void]
      [:rlEnableWireMode, :rlEnableWireMode, [], :void],

      # rlDisableWireMode : Disable wire mode
      # @return [void]
      [:rlDisableWireMode, :rlDisableWireMode, [], :void],

      # rlSetLineWidth : Set the line drawing width
      # @param width [float]
      # @return [void]
      [:rlSetLineWidth, :rlSetLineWidth, [:float], :void],

      # rlGetLineWidth : Get the line drawing width
      # @return [float]
      [:rlGetLineWidth, :rlGetLineWidth, [], :float],

      # rlEnableSmoothLines : Enable line aliasing
      # @return [void]
      [:rlEnableSmoothLines, :rlEnableSmoothLines, [], :void],

      # rlDisableSmoothLines : Disable line aliasing
      # @return [void]
      [:rlDisableSmoothLines, :rlDisableSmoothLines, [], :void],

      # rlEnableStereoRender : Enable stereo rendering
      # @return [void]
      [:rlEnableStereoRender, :rlEnableStereoRender, [], :void],

      # rlDisableStereoRender : Disable stereo rendering
      # @return [void]
      [:rlDisableStereoRender, :rlDisableStereoRender, [], :void],

      # rlIsStereoRenderEnabled : Check if stereo render is enabled
      # @return [bool]
      [:rlIsStereoRenderEnabled, :rlIsStereoRenderEnabled, [], :bool],

      # rlClearColor : Clear color buffer with color
      # @param r [unsigned char]
      # @param g [unsigned char]
      # @param b [unsigned char]
      # @param a [unsigned char]
      # @return [void]
      [:rlClearColor, :rlClearColor, [:uchar, :uchar, :uchar, :uchar], :void],

      # rlClearScreenBuffers : Clear used screen buffers (color and depth)
      # @return [void]
      [:rlClearScreenBuffers, :rlClearScreenBuffers, [], :void],

      # rlCheckErrors : Check and log OpenGL error codes
      # @return [void]
      [:rlCheckErrors, :rlCheckErrors, [], :void],

      # rlSetBlendMode : Set blending mode
      # @param mode [int]
      # @return [void]
      [:rlSetBlendMode, :rlSetBlendMode, [:int], :void],

      # rlSetBlendFactors : Set blending mode factor and equation (using OpenGL factors)
      # @param glSrcFactor [int]
      # @param glDstFactor [int]
      # @param glEquation [int]
      # @return [void]
      [:rlSetBlendFactors, :rlSetBlendFactors, [:int, :int, :int], :void],

      # rlSetBlendFactorsSeparate : Set blending mode factors and equations separately (using OpenGL factors)
      # @param glSrcRGB [int]
      # @param glDstRGB [int]
      # @param glSrcAlpha [int]
      # @param glDstAlpha [int]
      # @param glEqRGB [int]
      # @param glEqAlpha [int]
      # @return [void]
      [:rlSetBlendFactorsSeparate, :rlSetBlendFactorsSeparate, [:int, :int, :int, :int, :int, :int], :void],

      # rlglInit : Initialize rlgl (buffers, shaders, textures, states)
      # @param width [int]
      # @param height [int]
      # @return [void]
      [:rlglInit, :rlglInit, [:int, :int], :void],

      # rlglClose : De-inititialize rlgl (buffers, shaders, textures)
      # @return [void]
      [:rlglClose, :rlglClose, [], :void],

      # rlLoadExtensions : Load OpenGL extensions (loader function required)
      # @param loader [void *]
      # @return [void]
      [:rlLoadExtensions, :rlLoadExtensions, [:pointer], :void],

      # rlGetVersion : Get current OpenGL version
      # @return [int]
      [:rlGetVersion, :rlGetVersion, [], :int],

      # rlSetFramebufferWidth : Set current framebuffer width
      # @param width [int]
      # @return [void]
      [:rlSetFramebufferWidth, :rlSetFramebufferWidth, [:int], :void],

      # rlGetFramebufferWidth : Get default framebuffer width
      # @return [int]
      [:rlGetFramebufferWidth, :rlGetFramebufferWidth, [], :int],

      # rlSetFramebufferHeight : Set current framebuffer height
      # @param height [int]
      # @return [void]
      [:rlSetFramebufferHeight, :rlSetFramebufferHeight, [:int], :void],

      # rlGetFramebufferHeight : Get default framebuffer height
      # @return [int]
      [:rlGetFramebufferHeight, :rlGetFramebufferHeight, [], :int],

      # rlGetTextureIdDefault : Get default texture id
      # @return [unsigned int]
      [:rlGetTextureIdDefault, :rlGetTextureIdDefault, [], :uint],

      # rlGetShaderIdDefault : Get default shader id
      # @return [unsigned int]
      [:rlGetShaderIdDefault, :rlGetShaderIdDefault, [], :uint],

      # rlGetShaderLocsDefault : Get default shader locations
      # @return [int *]
      [:rlGetShaderLocsDefault, :rlGetShaderLocsDefault, [], :pointer],

      # rlLoadRenderBatch : Load a render batch system
      # @param numBuffers [int]
      # @param bufferElements [int]
      # @return [rlRenderBatch]
      [:rlLoadRenderBatch, :rlLoadRenderBatch, [:int, :int], RlRenderBatch.by_value],

      # rlUnloadRenderBatch : Unload render batch system
      # @param batch [rlRenderBatch]
      # @return [void]
      [:rlUnloadRenderBatch, :rlUnloadRenderBatch, [RlRenderBatch.by_value], :void],

      # rlDrawRenderBatch : Draw render batch data (Update->Draw->Reset)
      # @param batch [rlRenderBatch *]
      # @return [void]
      [:rlDrawRenderBatch, :rlDrawRenderBatch, [:pointer], :void],

      # rlSetRenderBatchActive : Set the active render batch for rlgl (NULL for default internal)
      # @param batch [rlRenderBatch *]
      # @return [void]
      [:rlSetRenderBatchActive, :rlSetRenderBatchActive, [:pointer], :void],

      # rlDrawRenderBatchActive : Update and draw internal render batch
      # @return [void]
      [:rlDrawRenderBatchActive, :rlDrawRenderBatchActive, [], :void],

      # rlCheckRenderBatchLimit : Check internal buffer overflow for a given number of vertex
      # @param vCount [int]
      # @return [bool]
      [:rlCheckRenderBatchLimit, :rlCheckRenderBatchLimit, [:int], :bool],

      # rlSetTexture : Set current texture for render batch and check buffers limits
      # @param id [unsigned int]
      # @return [void]
      [:rlSetTexture, :rlSetTexture, [:uint], :void],

      # rlLoadVertexArray : Load vertex array (vao) if supported
      # @return [unsigned int]
      [:rlLoadVertexArray, :rlLoadVertexArray, [], :uint],

      # rlLoadVertexBuffer : Load a vertex buffer attribute
      # @param buffer [const void *]
      # @param size [int]
      # @param dynamic [bool]
      # @return [unsigned int]
      [:rlLoadVertexBuffer, :rlLoadVertexBuffer, [:pointer, :int, :bool], :uint],

      # rlLoadVertexBufferElement : Load a new attributes element buffer
      # @param buffer [const void *]
      # @param size [int]
      # @param dynamic [bool]
      # @return [unsigned int]
      [:rlLoadVertexBufferElement, :rlLoadVertexBufferElement, [:pointer, :int, :bool], :uint],

      # rlUpdateVertexBuffer : Update GPU buffer with new data
      # @param bufferId [unsigned int]
      # @param data [const void *]
      # @param dataSize [int]
      # @param offset [int]
      # @return [void]
      [:rlUpdateVertexBuffer, :rlUpdateVertexBuffer, [:uint, :pointer, :int, :int], :void],

      # rlUpdateVertexBufferElements : Update vertex buffer elements with new data
      # @param id [unsigned int]
      # @param data [const void *]
      # @param dataSize [int]
      # @param offset [int]
      # @return [void]
      [:rlUpdateVertexBufferElements, :rlUpdateVertexBufferElements, [:uint, :pointer, :int, :int], :void],

      # rlUnloadVertexArray
      # @param vaoId [unsigned int]
      # @return [void]
      [:rlUnloadVertexArray, :rlUnloadVertexArray, [:uint], :void],

      # rlUnloadVertexBuffer
      # @param vboId [unsigned int]
      # @return [void]
      [:rlUnloadVertexBuffer, :rlUnloadVertexBuffer, [:uint], :void],

      # rlSetVertexAttribute
      # @param index [unsigned int]
      # @param compSize [int]
      # @param type [int]
      # @param normalized [bool]
      # @param stride [int]
      # @param pointer [const void *]
      # @return [void]
      [:rlSetVertexAttribute, :rlSetVertexAttribute, [:uint, :int, :int, :bool, :int, :pointer], :void],

      # rlSetVertexAttributeDivisor
      # @param index [unsigned int]
      # @param divisor [int]
      # @return [void]
      [:rlSetVertexAttributeDivisor, :rlSetVertexAttributeDivisor, [:uint, :int], :void],

      # rlSetVertexAttributeDefault : Set vertex attribute default value
      # @param locIndex [int]
      # @param value [const void *]
      # @param attribType [int]
      # @param count [int]
      # @return [void]
      [:rlSetVertexAttributeDefault, :rlSetVertexAttributeDefault, [:int, :pointer, :int, :int], :void],

      # rlDrawVertexArray
      # @param offset [int]
      # @param count [int]
      # @return [void]
      [:rlDrawVertexArray, :rlDrawVertexArray, [:int, :int], :void],

      # rlDrawVertexArrayElements
      # @param offset [int]
      # @param count [int]
      # @param buffer [const void *]
      # @return [void]
      [:rlDrawVertexArrayElements, :rlDrawVertexArrayElements, [:int, :int, :pointer], :void],

      # rlDrawVertexArrayInstanced
      # @param offset [int]
      # @param count [int]
      # @param instances [int]
      # @return [void]
      [:rlDrawVertexArrayInstanced, :rlDrawVertexArrayInstanced, [:int, :int, :int], :void],

      # rlDrawVertexArrayElementsInstanced
      # @param offset [int]
      # @param count [int]
      # @param buffer [const void *]
      # @param instances [int]
      # @return [void]
      [:rlDrawVertexArrayElementsInstanced, :rlDrawVertexArrayElementsInstanced, [:int, :int, :pointer, :int], :void],

      # rlLoadTexture : Load texture in GPU
      # @param data [const void *]
      # @param width [int]
      # @param height [int]
      # @param format [int]
      # @param mipmapCount [int]
      # @return [unsigned int]
      [:rlLoadTexture, :rlLoadTexture, [:pointer, :int, :int, :int, :int], :uint],

      # rlLoadTextureDepth : Load depth texture/renderbuffer (to be attached to fbo)
      # @param width [int]
      # @param height [int]
      # @param useRenderBuffer [bool]
      # @return [unsigned int]
      [:rlLoadTextureDepth, :rlLoadTextureDepth, [:int, :int, :bool], :uint],

      # rlLoadTextureCubemap : Load texture cubemap
      # @param data [const void *]
      # @param size [int]
      # @param format [int]
      # @return [unsigned int]
      [:rlLoadTextureCubemap, :rlLoadTextureCubemap, [:pointer, :int, :int], :uint],

      # rlUpdateTexture : Update GPU texture with new data
      # @param id [unsigned int]
      # @param offsetX [int]
      # @param offsetY [int]
      # @param width [int]
      # @param height [int]
      # @param format [int]
      # @param data [const void *]
      # @return [void]
      [:rlUpdateTexture, :rlUpdateTexture, [:uint, :int, :int, :int, :int, :int, :pointer], :void],

      # rlGetGlTextureFormats : Get OpenGL internal formats
      # @param format [int]
      # @param glInternalFormat [unsigned int *]
      # @param glFormat [unsigned int *]
      # @param glType [unsigned int *]
      # @return [void]
      [:rlGetGlTextureFormats, :rlGetGlTextureFormats, [:int, :pointer, :pointer, :pointer], :void],

      # rlGetPixelFormatName : Get name string for pixel format
      # @param format [unsigned int]
      # @return [const char *]
      [:rlGetPixelFormatName, :rlGetPixelFormatName, [:uint], :pointer],

      # rlUnloadTexture : Unload texture from GPU memory
      # @param id [unsigned int]
      # @return [void]
      [:rlUnloadTexture, :rlUnloadTexture, [:uint], :void],

      # rlGenTextureMipmaps : Generate mipmap data for selected texture
      # @param id [unsigned int]
      # @param width [int]
      # @param height [int]
      # @param format [int]
      # @param mipmaps [int *]
      # @return [void]
      [:rlGenTextureMipmaps, :rlGenTextureMipmaps, [:uint, :int, :int, :int, :pointer], :void],

      # rlReadTexturePixels : Read texture pixel data
      # @param id [unsigned int]
      # @param width [int]
      # @param height [int]
      # @param format [int]
      # @return [void *]
      [:rlReadTexturePixels, :rlReadTexturePixels, [:uint, :int, :int, :int], :pointer],

      # rlReadScreenPixels : Read screen pixel data (color buffer)
      # @param width [int]
      # @param height [int]
      # @return [unsigned char *]
      [:rlReadScreenPixels, :rlReadScreenPixels, [:int, :int], :pointer],

      # rlLoadFramebuffer : Load an empty framebuffer
      # @param width [int]
      # @param height [int]
      # @return [unsigned int]
      [:rlLoadFramebuffer, :rlLoadFramebuffer, [:int, :int], :uint],

      # rlFramebufferAttach : Attach texture/renderbuffer to a framebuffer
      # @param fboId [unsigned int]
      # @param texId [unsigned int]
      # @param attachType [int]
      # @param texType [int]
      # @param mipLevel [int]
      # @return [void]
      [:rlFramebufferAttach, :rlFramebufferAttach, [:uint, :uint, :int, :int, :int], :void],

      # rlFramebufferComplete : Verify framebuffer is complete
      # @param id [unsigned int]
      # @return [bool]
      [:rlFramebufferComplete, :rlFramebufferComplete, [:uint], :bool],

      # rlUnloadFramebuffer : Delete framebuffer from GPU
      # @param id [unsigned int]
      # @return [void]
      [:rlUnloadFramebuffer, :rlUnloadFramebuffer, [:uint], :void],

      # rlLoadShaderCode : Load shader from code strings
      # @param vsCode [const char *]
      # @param fsCode [const char *]
      # @return [unsigned int]
      [:rlLoadShaderCode, :rlLoadShaderCode, [:pointer, :pointer], :uint],

      # rlCompileShader : Compile custom shader and return shader id (type: RL_VERTEX_SHADER, RL_FRAGMENT_SHADER, RL_COMPUTE_SHADER)
      # @param shaderCode [const char *]
      # @param type [int]
      # @return [unsigned int]
      [:rlCompileShader, :rlCompileShader, [:pointer, :int], :uint],

      # rlLoadShaderProgram : Load custom shader program
      # @param vShaderId [unsigned int]
      # @param fShaderId [unsigned int]
      # @return [unsigned int]
      [:rlLoadShaderProgram, :rlLoadShaderProgram, [:uint, :uint], :uint],

      # rlUnloadShaderProgram : Unload shader program
      # @param id [unsigned int]
      # @return [void]
      [:rlUnloadShaderProgram, :rlUnloadShaderProgram, [:uint], :void],

      # rlGetLocationUniform : Get shader location uniform
      # @param shaderId [unsigned int]
      # @param uniformName [const char *]
      # @return [int]
      [:rlGetLocationUniform, :rlGetLocationUniform, [:uint, :pointer], :int],

      # rlGetLocationAttrib : Get shader location attribute
      # @param shaderId [unsigned int]
      # @param attribName [const char *]
      # @return [int]
      [:rlGetLocationAttrib, :rlGetLocationAttrib, [:uint, :pointer], :int],

      # rlSetUniform : Set shader value uniform
      # @param locIndex [int]
      # @param value [const void *]
      # @param uniformType [int]
      # @param count [int]
      # @return [void]
      [:rlSetUniform, :rlSetUniform, [:int, :pointer, :int, :int], :void],

      # rlSetUniformMatrix : Set shader value matrix
      # @param locIndex [int]
      # @param mat [Matrix]
      # @return [void]
      [:rlSetUniformMatrix, :rlSetUniformMatrix, [:int, Matrix.by_value], :void],

      # rlSetUniformSampler : Set shader value sampler
      # @param locIndex [int]
      # @param textureId [unsigned int]
      # @return [void]
      [:rlSetUniformSampler, :rlSetUniformSampler, [:int, :uint], :void],

      # rlSetShader : Set shader currently active (id and locations)
      # @param id [unsigned int]
      # @param locs [int *]
      # @return [void]
      [:rlSetShader, :rlSetShader, [:uint, :pointer], :void],

      # rlLoadComputeShaderProgram : Load compute shader program
      # @param shaderId [unsigned int]
      # @return [unsigned int]
      [:rlLoadComputeShaderProgram, :rlLoadComputeShaderProgram, [:uint], :uint],

      # rlComputeShaderDispatch : Dispatch compute shader (equivalent to *draw* for graphics pilepine)
      # @param groupX [unsigned int]
      # @param groupY [unsigned int]
      # @param groupZ [unsigned int]
      # @return [void]
      [:rlComputeShaderDispatch, :rlComputeShaderDispatch, [:uint, :uint, :uint], :void],

      # rlLoadShaderBuffer : Load shader storage buffer object (SSBO)
      # @param size [unsigned int]
      # @param data [const void *]
      # @param usageHint [int]
      # @return [unsigned int]
      [:rlLoadShaderBuffer, :rlLoadShaderBuffer, [:uint, :pointer, :int], :uint],

      # rlUnloadShaderBuffer : Unload shader storage buffer object (SSBO)
      # @param ssboId [unsigned int]
      # @return [void]
      [:rlUnloadShaderBuffer, :rlUnloadShaderBuffer, [:uint], :void],

      # rlUpdateShaderBuffer : Update SSBO buffer data
      # @param id [unsigned int]
      # @param data [const void *]
      # @param dataSize [unsigned int]
      # @param offset [unsigned int]
      # @return [void]
      [:rlUpdateShaderBuffer, :rlUpdateShaderBuffer, [:uint, :pointer, :uint, :uint], :void],

      # rlBindShaderBuffer : Bind SSBO buffer
      # @param id [unsigned int]
      # @param index [unsigned int]
      # @return [void]
      [:rlBindShaderBuffer, :rlBindShaderBuffer, [:uint, :uint], :void],

      # rlReadShaderBuffer : Read SSBO buffer data (GPU->CPU)
      # @param id [unsigned int]
      # @param dest [void *]
      # @param count [unsigned int]
      # @param offset [unsigned int]
      # @return [void]
      [:rlReadShaderBuffer, :rlReadShaderBuffer, [:uint, :pointer, :uint, :uint], :void],

      # rlCopyShaderBuffer : Copy SSBO data between buffers
      # @param destId [unsigned int]
      # @param srcId [unsigned int]
      # @param destOffset [unsigned int]
      # @param srcOffset [unsigned int]
      # @param count [unsigned int]
      # @return [void]
      [:rlCopyShaderBuffer, :rlCopyShaderBuffer, [:uint, :uint, :uint, :uint, :uint], :void],

      # rlGetShaderBufferSize : Get SSBO buffer size
      # @param id [unsigned int]
      # @return [unsigned int]
      [:rlGetShaderBufferSize, :rlGetShaderBufferSize, [:uint], :uint],

      # rlBindImageTexture : Bind image texture
      # @param id [unsigned int]
      # @param index [unsigned int]
      # @param format [int]
      # @param readonly [bool]
      # @return [void]
      [:rlBindImageTexture, :rlBindImageTexture, [:uint, :uint, :int, :bool], :void],

      # rlGetMatrixModelview : Get internal modelview matrix
      # @return [Matrix]
      [:rlGetMatrixModelview, :rlGetMatrixModelview, [], Matrix.by_value],

      # rlGetMatrixProjection : Get internal projection matrix
      # @return [Matrix]
      [:rlGetMatrixProjection, :rlGetMatrixProjection, [], Matrix.by_value],

      # rlGetMatrixTransform : Get internal accumulated transform matrix
      # @return [Matrix]
      [:rlGetMatrixTransform, :rlGetMatrixTransform, [], Matrix.by_value],

      # rlGetMatrixProjectionStereo : Get internal projection matrix for stereo render (selected eye)
      # @param eye [int]
      # @return [Matrix]
      [:rlGetMatrixProjectionStereo, :rlGetMatrixProjectionStereo, [:int], Matrix.by_value],

      # rlGetMatrixViewOffsetStereo : Get internal view offset matrix for stereo render (selected eye)
      # @param eye [int]
      # @return [Matrix]
      [:rlGetMatrixViewOffsetStereo, :rlGetMatrixViewOffsetStereo, [:int], Matrix.by_value],

      # rlSetMatrixProjection : Set a custom projection matrix (replaces internal projection matrix)
      # @param proj [Matrix]
      # @return [void]
      [:rlSetMatrixProjection, :rlSetMatrixProjection, [Matrix.by_value], :void],

      # rlSetMatrixModelview : Set a custom modelview matrix (replaces internal modelview matrix)
      # @param view [Matrix]
      # @return [void]
      [:rlSetMatrixModelview, :rlSetMatrixModelview, [Matrix.by_value], :void],

      # rlSetMatrixProjectionStereo : Set eyes projection matrices for stereo rendering
      # @param right [Matrix]
      # @param left [Matrix]
      # @return [void]
      [:rlSetMatrixProjectionStereo, :rlSetMatrixProjectionStereo, [Matrix.by_value, Matrix.by_value], :void],

      # rlSetMatrixViewOffsetStereo : Set eyes view offsets matrices for stereo rendering
      # @param right [Matrix]
      # @param left [Matrix]
      # @return [void]
      [:rlSetMatrixViewOffsetStereo, :rlSetMatrixViewOffsetStereo, [Matrix.by_value, Matrix.by_value], :void],

      # rlLoadDrawCube : Load and draw a cube
      # @return [void]
      [:rlLoadDrawCube, :rlLoadDrawCube, [], :void],

      # rlLoadDrawQuad : Load and draw a quad
      # @return [void]
      [:rlLoadDrawQuad, :rlLoadDrawQuad, [], :void],
    ]
    entries.each do |entry|
      attach_function entry[0], entry[1], entry[2], entry[3]
    rescue FFI::NotFoundError => e
      warn "[Warning] Failed to import #{entry[0]} (#{e})."
    end
  end
end
