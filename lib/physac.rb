# Yet another raylib wrapper for Ruby
#
# * https://github.com/vaiorabbit/raylib-bindings
#
# [NOTICE] Autogenerated. Do not edit.

require 'ffi'

module Raylib
  extend FFI::Library

  # Define/Macro

  PHYSAC_MAX_BODIES = 64 # Maximum number of physic bodies supported
  PHYSAC_MAX_MANIFOLDS = 4096 # Maximum number of physic bodies interactions (64x64)
  PHYSAC_MAX_VERTICES = 24 # Maximum number of vertex for polygons shapes
  PHYSAC_DEFAULT_CIRCLE_VERTICES = 24 # Default number of vertices for circle shapes
  PHYSAC_COLLISION_ITERATIONS = 100
  PHYSAC_PENETRATION_ALLOWANCE = 0.05
  PHYSAC_PENETRATION_CORRECTION = 0.4
  PHYSAC_PI = 3.14159265358979323846

  # Enum

  # enum PhysicsShapeType
  PHYSICS_CIRCLE = 0
  PHYSICS_POLYGON = 1


  # Typedef

  typedef :int, :PhysicsShapeType
  typedef :pointer, :PhysicsBody
  typedef :pointer, :PhysicsManifold

  # Struct

  # Matrix2x2 type (used for polygon shape rotation matrix)
  class Matrix2x2 < FFI::Struct
    layout(
      :m00, :float,
      :m01, :float,
      :m10, :float,
      :m11, :float,
    )
  end

  class PhysicsVertexData < FFI::Struct
    layout(
      :vertexCount, :uint, # Vertex count (positions and normals)
      :positions, [Vector2, 24], # Vertex positions vectors
      :normals, [Vector2, 24], # Vertex normals vectors
    )
  end

  class PhysicsShape < FFI::Struct
    layout(
      :type, :int, # Shape type (circle or polygon)
      :body, :pointer, # Shape physics body data pointer
      :vertexData, PhysicsVertexData, # Shape vertices data (used for polygon shapes)
      :radius, :float, # Shape radius (used for circle shapes)
      :transform, Matrix2x2, # Vertices transform matrix 2x2
    )
  end

  class PhysicsBodyData < FFI::Struct
    layout(
      :id, :uint, # Unique identifier
      :enabled, :bool, # Enabled dynamics state (collisions are calculated anyway)
      :position, Vector2, # Physics body shape pivot
      :velocity, Vector2, # Current linear velocity applied to position
      :force, Vector2, # Current linear force (reset to 0 every step)
      :angularVelocity, :float, # Current angular velocity applied to orient
      :torque, :float, # Current angular force (reset to 0 every step)
      :orient, :float, # Rotation in radians
      :inertia, :float, # Moment of inertia
      :inverseInertia, :float, # Inverse value of inertia
      :mass, :float, # Physics body mass
      :inverseMass, :float, # Inverse value of mass
      :staticFriction, :float, # Friction when the body has not movement (0 to 1)
      :dynamicFriction, :float, # Friction when the body has movement (0 to 1)
      :restitution, :float, # Restitution coefficient of the body (0 to 1)
      :useGravity, :bool, # Apply gravity force to dynamics
      :isGrounded, :bool, # Physics grounded on other body state
      :freezeOrient, :bool, # Physics rotation constraint
      :shape, PhysicsShape, # Physics body shape information (type, radius, vertices, transform)
    )
  end

  class PhysicsManifoldData < FFI::Struct
    layout(
      :id, :uint, # Unique identifier
      :bodyA, :pointer, # Manifold first physics body reference
      :bodyB, :pointer, # Manifold second physics body reference
      :penetration, :float, # Depth of penetration from collision
      :normal, Vector2, # Normal direction vector from 'a' to 'b'
      :contacts, [Vector2, 2], # Points of contact during collision
      :contactsCount, :uint, # Current collision number of contacts
      :restitution, :float, # Mixed restitution during collision
      :dynamicFriction, :float, # Mixed dynamic friction during collision
      :staticFriction, :float, # Mixed static friction during collision
    )
  end


  # Function

  def self.setup_physac_symbols
    entries = [

      # InitPhysics : Initializes physics system
      # @return [void]
      [:InitPhysics, :InitPhysics, [], :void],

      # UpdatePhysics : Update physics system
      # @return [void]
      [:UpdatePhysics, :UpdatePhysics, [], :void],

      # ResetPhysics : Reset physics system (global variables)
      # @return [void]
      [:ResetPhysics, :ResetPhysics, [], :void],

      # ClosePhysics : Close physics system and unload used memory
      # @return [void]
      [:ClosePhysics, :ClosePhysics, [], :void],

      # SetPhysicsTimeStep : Sets physics fixed time step in milliseconds. 1.666666 by default
      # @param delta [double]
      # @return [void]
      [:SetPhysicsTimeStep, :SetPhysicsTimeStep, [:double], :void],

      # SetPhysicsGravity : Sets physics global gravity force
      # @param x [float]
      # @param y [float]
      # @return [void]
      [:SetPhysicsGravity, :SetPhysicsGravity, [:float, :float], :void],

      # CreatePhysicsBodyCircle : Creates a new circle physics body with generic parameters
      # @param pos [Vector2]
      # @param radius [float]
      # @param density [float]
      # @return [PhysicsBody]
      [:CreatePhysicsBodyCircle, :CreatePhysicsBodyCircle, [Vector2.by_value, :float, :float], :pointer],

      # CreatePhysicsBodyRectangle : Creates a new rectangle physics body with generic parameters
      # @param pos [Vector2]
      # @param width [float]
      # @param height [float]
      # @param density [float]
      # @return [PhysicsBody]
      [:CreatePhysicsBodyRectangle, :CreatePhysicsBodyRectangle, [Vector2.by_value, :float, :float, :float], :pointer],

      # CreatePhysicsBodyPolygon : Creates a new polygon physics body with generic parameters
      # @param pos [Vector2]
      # @param radius [float]
      # @param sides [int]
      # @param density [float]
      # @return [PhysicsBody]
      [:CreatePhysicsBodyPolygon, :CreatePhysicsBodyPolygon, [Vector2.by_value, :float, :int, :float], :pointer],

      # DestroyPhysicsBody : Destroy a physics body
      # @param body [PhysicsBody]
      # @return [void]
      [:DestroyPhysicsBody, :DestroyPhysicsBody, [:pointer], :void],

      # PhysicsAddForce : Adds a force to a physics body
      # @param body [PhysicsBody]
      # @param force [Vector2]
      # @return [void]
      [:PhysicsAddForce, :PhysicsAddForce, [:pointer, Vector2.by_value], :void],

      # PhysicsAddTorque : Adds an angular force to a physics body
      # @param body [PhysicsBody]
      # @param amount [float]
      # @return [void]
      [:PhysicsAddTorque, :PhysicsAddTorque, [:pointer, :float], :void],

      # PhysicsShatter : Shatters a polygon shape physics body to little physics bodies with explosion force
      # @param body [PhysicsBody]
      # @param position [Vector2]
      # @param force [float]
      # @return [void]
      [:PhysicsShatter, :PhysicsShatter, [:pointer, Vector2.by_value, :float], :void],

      # SetPhysicsBodyRotation : Sets physics body shape transform based on radians parameter
      # @param body [PhysicsBody]
      # @param radians [float]
      # @return [void]
      [:SetPhysicsBodyRotation, :SetPhysicsBodyRotation, [:pointer, :float], :void],

      # GetPhysicsBody : Returns a physics body of the bodies pool at a specific index
      # @param index [int]
      # @return [PhysicsBody]
      [:GetPhysicsBody, :GetPhysicsBody, [:int], :pointer],

      # GetPhysicsBodiesCount : Returns the current amount of created physics bodies
      # @return [int]
      [:GetPhysicsBodiesCount, :GetPhysicsBodiesCount, [], :int],

      # GetPhysicsShapeType : Returns the physics body shape type (PHYSICS_CIRCLE or PHYSICS_POLYGON)
      # @param index [int]
      # @return [int]
      [:GetPhysicsShapeType, :GetPhysicsShapeType, [:int], :int],

      # GetPhysicsShapeVerticesCount : Returns the amount of vertices of a physics body shape
      # @param index [int]
      # @return [int]
      [:GetPhysicsShapeVerticesCount, :GetPhysicsShapeVerticesCount, [:int], :int],

      # GetPhysicsShapeVertex : Returns transformed position of a body shape (body position + vertex transformed position)
      # @param body [PhysicsBody]
      # @param vertex [int]
      # @return [Vector2]
      [:GetPhysicsShapeVertex, :GetPhysicsShapeVertex, [:pointer, :int], Vector2.by_value],
    ]
    entries.each do |entry|
      attach_function entry[0], entry[1], entry[2], entry[3]
    rescue FFI::NotFoundError => e
      warn "[Warning] Failed to import #{entry[0]} (#{e})."
    end
  end
end
