import ctypes, re, sys
import json
import raylib_parser

PREFIX = """# Yet another raylib wrapper for Ruby
#
# * https://github.com/vaiorabbit/raylib-bindings
#
# [NOTICE] Autogenerated. Do not edit.

require 'ffi'
"""

POSTFIX = 'end'

####################################################################################################

def sanitize_enum(ctx):
    pass

def sanitize_macro(ctx):
    # 0x____u -> 0x____
    pattern = re.compile(r'(0x[0-9a-fA-F]+)u')
    for macro_name, macro_value in ctx.decl_macros.items():
        if len(macro_value) != 1:
            continue
        m = re.search(pattern, macro_value[0])
        if m:
            ctx.decl_macros[macro_name][0] = m.group(1)

    # refer mapping
    for macro_name, macro_value in ctx.decl_macros.items():
        define_mapping = raylib_parser.get_define_mapping(macro_name)
        if define_mapping:
            ctx.decl_macros[macro_name] = define_mapping
        else:
            ctx.decl_macros[macro_name] = None

    # contatinate (SDL_INIT_EVERYTHING, etc.)
    for macro_name, macro_value in ctx.decl_macros.items():
        if macro_value == None or len(macro_value) <= 1:
            continue
        ctx.decl_macros[macro_name] = [''.join(macro_value)]

def sanitize_struct(ctx):
    for struct_name, struct_info in ctx.decl_structs.items():
        if struct_info == None:
            continue
        underlying_ctypes_type = "FFI::Union" if str(struct_info.kind) == "CursorKind.UNION_DECL" else "FFI::Struct"
        struct_info.kind = underlying_ctypes_type
        for field in struct_info.fields:
            field.type_kind = raylib_parser.get_cindex_ctypes_mapping(str(field.type_kind), field.type_name)

def sanitize_typedef(ctx):
    # refer mapping
    for typedef_name, typedef_info in ctx.decl_typedefs.items():
        if typedef_info.func_proto != None:
            for arg in typedef_info.func_proto.args:
                arg.type_kind = raylib_parser.get_cindex_ctypes_mapping(str(arg.type_kind), arg.type_name)
            typedef_info.func_proto.retval.type_kind = raylib_parser.get_cindex_ctypes_mapping(str(typedef_info.func_proto.retval.type_kind), typedef_info.func_proto.retval.type_name)
        else:
            if str(typedef_info.type_kind) == "TypeKind.RECORD":
                typedef_info.type_kind = None
            else:
                typedef_info.type_kind = raylib_parser.get_cindex_ctypes_mapping(str(typedef_info.type_kind), typedef_info.name)

def sanitize_function(ctx):
    for func_name, func_info in ctx.decl_functions.items():
        if func_info == None:
            continue
        for arg in func_info.args:
            if raylib_parser.is_raylib_callback_type(arg.type_kind, arg.type_name):
                arg.type_kind = ":" + arg.type_name
            else:
                arg.type_kind = raylib_parser.get_cindex_ctypes_mapping(str(arg.type_kind), arg.type_name)
        func_info.retval.type_kind = raylib_parser.get_cindex_ctypes_mapping(str(func_info.retval.type_kind), func_info.retval.type_name)

def sanitize(ctx):
    sanitize_enum(ctx)
    sanitize_macro(ctx)
    sanitize_struct(ctx)
    sanitize_typedef(ctx)
    sanitize_function(ctx)

####################################################################################################

def generate_macrodefine(ctx, indent = "", json_schema=None):
    json_defines = None
    if json_schema:
        json_defines = json_schema['defines']

    for macro_name, macro_value in ctx.decl_macros.items():
        if macro_value != None:
            description = ""
            if json_defines:
                json_define = [json_define for json_define in json_defines if json_define['name'] == macro_name][0]
                description = json_define['description']
            if description != "":
                print(indent + "%s = %s # %s" % (macro_name, macro_value[0], description.strip()), file = sys.stdout)
            else:
                print(indent + "%s = %s" % (macro_name, macro_value[0]), file = sys.stdout)

def generate_enum(ctx, indent = "", json_schema=None):
    json_enums = None
    if json_schema:
        json_enums = json_schema['enums']

    enum_typedefs = {}

    for enum_value in ctx.decl_enums.values():
        for enum in enum_value:
            json_enum_value = None
            for json_enum in json_enums:
                json_enum_values = json_enum['values']
                json_enum_value = [j for j in json_enum_values if j['name'] == enum[0]]
                if json_enum_value:
                    break
            enum_value_description = json_enum_value[0]['description'] if json_enum_value != None else ""

            enum_typedef_name = ctx.enum_constants[enum[0]].typedef_name
            if enum_typedef_name not in enum_typedefs.keys():
                enum_typedefs[enum_typedef_name] = []
            enum_typedefs[enum_typedef_name].append([enum[0], enum[1], enum_value_description])

    enum_descriptions = {}

    for json_enum in json_enums:
        enum_descriptions[json_enum['name']] = json_enum['description']

    for enum_typedef_name, enum_info_array in enum_typedefs.items():
        print(indent + "# enum " + enum_typedef_name)
        if enum_typedef_name in enum_descriptions.keys():
            print(indent + "# " + enum_descriptions[enum_typedef_name])
        for enum_info in enum_info_array:
            if enum_info[2] != "":
                print(indent + "%s = %s # %s" % (enum_info[0], enum_info[1], enum_info[2]), file = sys.stdout)
            else:
                print(indent + "%s = %s" % (enum_info[0], enum_info[1]), file = sys.stdout)
        print("", file = sys.stdout)


def generate_typedef(ctx, indent = "", typedef_prefix="", typedef_postfix=""):
    if typedef_prefix != "":
        print(typedef_prefix, file = sys.stdout)
    for typedef_name, typedef_info in ctx.decl_typedefs.items():
        if typedef_info.type_kind == None:
            continue
        if typedef_info.func_proto != None:
            typedef_line = "callback :%s, ["  % typedef_name
            for i, arg in enumerate(typedef_info.func_proto.args):
                typedef_line += "%s%s" % ("" if i == 0 else ", ",  arg.type_kind)
            typedef_line += "], %s" % typedef_info.func_proto.retval.type_kind
        else:
            typedef_line = "typedef %s, :%s" % (typedef_info.type_kind, typedef_name)
        print(indent + typedef_line, file = sys.stdout)
    if typedef_postfix != "":
        print(typedef_postfix, file = sys.stdout)

def generate_structunion(ctx, indent = "", struct_prefix="", struct_postfix="", struct_alias=None, json_schema=None):
    json_structs = None
    if json_schema:
        json_structs = json_schema['structs']

    if struct_prefix != "":
        print(struct_prefix, file = sys.stdout)
    for struct_name, struct_info in ctx.decl_structs.items():
        if struct_info == None:
            continue

        json_struct = [j for j in json_structs if j['name'] == struct_name][0]
        struct_description = json_struct['description']

        # Name of struct/class must be start with capital letter
        if struct_description != "":
            print(indent + "# %s" % (struct_description), file = sys.stdout)
        struct_name = struct_name[0].upper() + struct_name[1:]
        print(indent + "class %s < %s" % (struct_name, struct_info.kind), file = sys.stdout)
        print(indent + "  layout(", file = sys.stdout)
        for field in struct_info.fields:
            json_field = [j for j in json_struct['fields'] if j['name'] == field.element_name]
            member_description = json_field[0]['description'] if json_field else ""
            if member_description != "":
                member_description = " # " + member_description
            if field.element_count <= 1:
                print(indent + "    :%s, %s,%s" % (field.element_name, field.type_kind, member_description), file = sys.stdout)
            else:
                print(indent + "    :%s, [%s, %s],%s" % (field.element_name, field.type_kind, field.element_count, member_description), file = sys.stdout)
        print(indent + "  )", file = sys.stdout)
        print(indent + "end\n", file = sys.stdout)
        if struct_alias:
            if struct_name in struct_alias.keys():
                names = struct_alias[struct_name]
                for name in names:
                    print(indent + name + ' = ' + struct_name, file = sys.stdout)
                print("", file = sys.stdout)
            pass
    if struct_postfix != "":
        print(struct_postfix, file = sys.stdout)


class FunctionEntry:
    def __init__(self, original_name, explicit_name):
        self.original_name = original_name
        self.explicit_name = explicit_name
        self.retval = None
        self.args = ""
        self.description = ""
        self.ret_description = ""
        self.arg_descriptions = []

def generate_function(ctx, indent = "", module_name = "", function_prefix = "", function_postfix = "", json_schema=None):
    json_functions = None
    if json_schema:
        json_functions = json_schema['functions']

    if function_prefix != "":
        print(function_prefix, file = sys.stdout)

    func_entries = []
    for func_name, func_info in ctx.decl_functions.items():
        if func_info == None:
            continue
        func_entry = FunctionEntry(func_info.original_name, func_info.explicit_name)

        # Collect documentation from JSON API Schema
        json_function = [j for j in json_functions if j['name'] == func_info.original_name][0]
        func_entry.description = json_function['description']
        func_entry.ret_description = json_function['returnType']
        if 'params' in json_function:
            for j in json_function['params']:
                func_entry.arg_descriptions.append([j['type'], j['name']])

        # Arguments
        if len(func_info.args) > 0:
            # Get Ruby FFI arguments
            args_ctype_list = list(map((lambda t: str(t.type_kind)), func_info.args))

            # Capitalize and add ".by_value" to struct arguments (e.g.: Color -> Color.by_value)
            arg_is_record = lambda arg: raylib_parser.query_raylib_cindex_mapping_entry_exists(arg) and raylib_parser.get_raylib_cindex_mapping_value(arg) == "TypeKind.RECORD"
            args_ctype_list = list(map((lambda arg: arg[0].upper() + arg[1:] + ".by_value" if arg_is_record(arg) else arg), args_ctype_list))

            func_entry.args = ', '.join(args_ctype_list)

        # Return value
        # Capitalize and add ".by_value" to struct return value (e.g.: Color -> Color.by_value, float3 -> Float3.by_value)
        retval_is_record = raylib_parser.query_raylib_cindex_mapping_entry_exists(func_info.retval.type_kind) and raylib_parser.get_raylib_cindex_mapping_value(func_info.retval.type_kind) == "TypeKind.RECORD"
        name = str(func_info.retval.type_kind)
        retval_str = name[0].upper() + name[1:] + ".by_value" if retval_is_record else name

        func_entry.retval =  retval_str

        func_entries.append(func_entry)

    print(indent + "def self.setup_%s_symbols" % module_name , file = sys.stdout)
    indent = "  "
    print(indent + "  entries = [", file = sys.stdout)
    for func_entry in func_entries:
        entry_str = f':{func_entry.explicit_name}, :{func_entry.original_name}, [{func_entry.args}], {func_entry.retval}'
        print('', file = sys.stdout)
        if func_entry.description != "":
            print(indent + f'    # {func_entry.explicit_name} : {func_entry.description}', file = sys.stdout)
        else:
            print(indent + f'    # {func_entry.explicit_name}', file = sys.stdout)
        for arg_description in func_entry.arg_descriptions:
            print(indent + f'    # @param {arg_description[1]} [{arg_description[0]}]', file = sys.stdout)
        print(indent + f'    # @return [{func_entry.ret_description}]', file = sys.stdout)
        print(indent + f'    [{entry_str}],', file = sys.stdout)
    print(indent + "  ]", file = sys.stdout)

    print(indent +
      """  entries.each do |entry|
      attach_function entry[0], entry[1], entry[2], entry[3]
    rescue FFI::NotFoundError => e
      warn "[Warning] Failed to import #{s}."
    end""".format(s="{entry[0]} (#{e})"))
    #print(indent + "  end", file = sys.stdout)

    indent = "  "
    print(indent + "end", file = sys.stdout)

    if function_postfix != "":
        print(function_postfix, file = sys.stdout)

def generate(ctx, prefix = PREFIX, postfix = POSTFIX, *, module_name = "", table_prefix = "Raylib_", typedef_prefix="", typedef_postfix="", struct_prefix="", struct_postfix="", struct_alias=None, function_prefix="", function_postfix="", json_schema=None):

    print(prefix, file = sys.stdout)

    print("module Raylib")

    indent = "  "

    print(indent + "extend FFI::Library")

    # macro
    if len(ctx.decl_macros) > 0:
        print("")
        print(indent + "# Define/Macro\n", file = sys.stdout)
        generate_macrodefine(ctx, indent, json_schema)
        print("", file = sys.stdout)

    # enum
    if len(ctx.decl_enums) > 0:
        print(indent + "# Enum\n", file = sys.stdout)
        generate_enum(ctx, indent, json_schema)
        print("", file = sys.stdout)

    # typedef
    if len(ctx.decl_typedefs) > 0:
        print(indent + "# Typedef\n", file = sys.stdout)
        generate_typedef(ctx, indent, typedef_prefix, typedef_postfix)
        print("", file = sys.stdout)

    # struct/union
    if len(ctx.decl_structs) > 0:
        print(indent + "# Struct\n", file = sys.stdout)
        generate_structunion(ctx, indent, struct_prefix, struct_postfix, struct_alias, json_schema)
        print("", file = sys.stdout)

    # function
    if len(ctx.decl_functions) > 0:
        print(indent + "# Function\n", file = sys.stdout)
        generate_function(ctx, indent, module_name, function_prefix, function_postfix, json_schema)

    print(postfix, file = sys.stdout)

if __name__ == "__main__":
    pass
